
### Семафор 

``` go
type Semaphore struct {
    tickets chan struct{}
}

func NewSemaphore(ticketsNumber int) Semaphore {
    return Semaphore{
        tickets: make(chan struct{}, ticketsNumber),
    }
}

func (s *Semaphore) Acquire() {
    s.tickets <- struct{}{}
}

func (s *Semaphore) Release() {
    <-s.tickets
}

func main() {
    wg := sync.WaitGroup{}
    wg.Add(6)

    semaphore := NewSemaphore(5)

    for i := 0; i < 6; i++ {
        semaphore.Acquire()

        go func() {
            defer wg.Done()
            defer semaphore.Release()

            fmt.Println("working...")
            time.Sleep(time.Second * 2)
            fmt.Println("exiting...")
        }()
    }

    wg.Wait()
}
```



### Reusable cyclic barrier (многоразовый барьер для нескольких фаз/итераций)

- счётчика участников (count)
- мьютекса для защиты счётчика
- двух **буферизованных** каналов:
    - beforeCh — для фазы «все собрались перед действием»
    - afterCh — для фазы «все завершили действие и готовы к следующей итерации»

Семантика:
1. Есть count горутин-воркеров
2. В каждой итерации (for j := 0; j < count; j++):
    - Все ждут, пока **все** не дойдут до Before() → тогда всем разрешают выполнить bootstrap()
    - Все выполняют bootstrap()
    - Все ждут, пока **все** не завершат bootstrap() → тогда всем разрешают выполнить work()
    - Все выполняют work()
    - И так count раз (т.е. 3 раза в твоём примере)

``` go
type Barrier struct {
    mutex      sync.Mutex
    count      int
    size       int
    beforeCh   chan struct{}
    afterCh    chan struct{}
}

func NewBarrier(size int) *Barrier {
    return &Barrier{
        size:       size,
        beforeCh:   make(chan struct{}, size),
        afterCh:    make(chan struct{}, size),
    }
}

func (b *Barrier) Before() {
    b.mutex.Lock()
    b.count++
    if b.count == b.size {
        for i := 0; i < b.size; i++ {
            b.beforeCh <- struct{}{}
        }
    }
    b.mutex.Unlock()
    <-b.beforeCh
}

func (b *Barrier) After() {
    b.mutex.Lock()
    b.count--
    if b.count == 0 {
        for i := 0; i < b.size; i++ {
            b.afterCh <- struct{}{}
        }
    }
    b.mutex.Unlock()
    <-b.afterCh
}

func main() {
    var wg sync.WaitGroup
    wg.Add(3)

    bootstrap := func() {
        log.Println("bootstrap")
    }

    work := func() {
        log.Println("work")
    }

    count := 3
    barrier := NewBarrier(count)

    for i := 0; i < count; i++ {
        go func() {
            defer wg.Done()

            for j := 0; j < count; j++ {
                // wait for all workers to finish previous loop
                barrier.Before()

                bootstrap()

                // wait for other workers to bootstrap
                barrier.After()

                work()
            }
        }()
    }

    wg.Wait()
}
```


### Promise 

``` go
type result[T any] struct {
	val T
	err error
}

type Promise[T any] struct {
	resultCh chan result[T]
}

func NewPromise[T any](asyncFn func() (T, error)) *Promise[T] {
	p := &Promise[T]{
		resultCh: make(chan result[T]),
	}

	go func() {
		defer close(p.resultCh)

		val, err := asyncFn()
		p.resultCh <- result[T]{val: val, err: err}
	}()

	return p
}

func (p *Promise[T]) Then(successFn func(T), errorFn func(error)) {
	go func() {
		res := <-p.resultCh
		if res.err == nil {
			successFn(res.err)
		} else {
			errorFn(res.val)
		}
	}()
}

func main() {
	asyncJob := func() (string, error) {
		time.Sleep(1 * time.Second)
		return "ok", nil
	}

	promise := NewPromise(asyncJob)
	promise.Then(
		func(value string) {
			fmt.Printf("success", value)
		},
		func(err error) {
			fmt.Printf("error", err.Error())
		},
	)

	time.Sleep(2 * time.Second)
}
```