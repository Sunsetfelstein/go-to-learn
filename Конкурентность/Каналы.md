
![[Pasted image 20260201212053.png]]

### Микропаттерн генератор 

``` go
func writer() <-chan int {
	ch := make(chan int)
	wg := &async.WaitGroup{}
	
	wg.Add(2)
	go func() {
		defer wg.Done()
		
		for i := range 5 {
			ch <- i + 1
		}
	}()
	
	go func() {
		defer wg.Done()
		
			for i := range 5 {
			ch <- i + 11
		}
	}()
	
	go func() {
		wg.Wait() // Т.к. это паттерн генератор, мы не должны блокировать основной поток
		close(ch)
	}
	
	return ch
} 
```

Пример 

``` go
package main

import (
    "fmt"
    "time"
)

func reader(inputCh <-chan int) {
    go func() {
        for v := range inputCh {
            fmt.Println(v)
        }
    }()
}

func doubler(inputCh <-chan int) <-chan int {
    ch := make(chan int)
    go func() {
        for v := range inputCh {
            time.Sleep(500 * time.Millisecond)
            ch <- 2 * v
        }
        close(ch)
    }() 
    return ch
}

func writer() <-chan int {
    ch := make(chan int)
    go func() {
        for i := range 10 {
            ch <- i + 1
        }
        close(ch)
    }()
    return ch
}

func main() {
    reader(doubler(writer()))
    time.Sleep(10 * time.Second)
}
```

Пример обертки, который останавливает функцию, если она работает дольше 3 секунд, с использованием Select и Context

``` go
func randomTimeWork() {
    time.Sleep(time.Duration(rand.Intn(100)) * time.Second)
}

func predictableTimeWork() {
    ch := make(chan struct{})
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    go func() {
        randomTimeWork()
        close(ch)
    }()

    select {
    case <-ch:
        fmt.Println("func is done")
        return
    case <-ctx.Done():
        fmt.Println("3 sec is over")
        return
    }
}

func main() {
    predictableTimeWork()
}
```

Можно использовать time.After(3 * time.Second) или timer.C (тут без секунд)

![[Pasted image 20260120000454.png]]

### Буферизированный канал

Буферизированный канал блокируется на чтении только тогда, когда буфер пустой

Буферизированный канал блокируется при записи только тогда, когда буфер заполнен полностью 

В случаях, если мы запускаем горутину, в которой читаем из канала в цикле, а в основной горутине пытаемся записать в цикле, и если цикл равен количеству буферу, то канал не заблокируется, мы выйдем из цикла, и программа может завершится до того, как мы вычитаем все данный из той горутины, где мы читали данные 

Пример использования 

``` go

ch := make(chan os.Sygnal, 1)
signal.Nofity(ch, os.Interrupt)

go ServerStart()

<-ch

fmt.Println("closing connection") //делаем полезную работу перед закрытием

```

В данном коде, при нажатии на Interrupt (ctrl + C) мы записываем в канал, так как буфер 1, то пакет signal не блокируется. (регистрируем канал как приемник)

Основной поток блокируем чтением из канала

В небуферизированном канале у нас данные передаются из стека в стек, в буферизированном само по себе не так, но если у нас есть готовый читатель и когда мы записываем в канал, в этот момент передается из стека в стек.

### Противодавление

``` go
package main

import (
	"errors"
	"net/http"
	"time"
)

type PressureGauge struct {
	ch chan struct{}
}

func New(limit int) *PressureGauge {
	return &PressureGauge{
		ch: make(chan struct{}, limit),
	}
}

func (pg *PressureGauge) Process(f func()) error {
	select {
	case pg.ch <- struct{}{}:
		f()
		<-pg.ch
		return nil
	default:
		return errors.New("no more capacity")
	}
}

func doThingThatShouldBeLimited() string {
	time.Sleep(2 * time.Second)
	return "done"
}

func main() {
	pg := New(10)
	http.HandleFunc("/request", func(w http.ResponseWriter, r *http.Request) {
		err := pg.Process(func() {
			w.Write([]byte(doThingThatShouldBeLimited()))
		})
		if err != nil {
			w.WriteHeader(http.StatusTooManyRequests)
			w.Write([]byte("Too many requests"))
		}
	})
	http.ListenAndServe(":8080", nil)
```