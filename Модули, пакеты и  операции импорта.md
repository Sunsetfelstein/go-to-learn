
Управление библиотеками в Go основано на трех концепциях, таких как репозитории, модули и пакеты. Что такое репозиторий, знает любой разработчик. Это место в системе управления версиями, где хранится исходный код проекта. Модуль — это комплект исходного кода на Go, который хранится в репозитории и распространяется как единое целое. Каждый модуль включает один или несколько пакетов — каталогов с исходным кодом, что придает модулю определенную структуру.

В Go в качестве идентификатора обычно используется путь к репозиторию, в котором находится модуль.
### go.mod

Команда go mod init ПУТЬ_К_МОДУЛЮ создаст файл go.mod, превращающий текущий каталог в корень модуля. ПУТЬ_К_МОДУЛЮ здесь представляет собой глобально уникальное имя, идентифицирующее модуль. Путь чувствителен к регистру. Во избежание путаницы не используйте в нем буквы верхнего регистра

Дерево каталогов с исходным кодом на языке Go становится модулем в том случае, если в его корневом каталоге имеется корректный файл go.mod.

``` txt
module github.com/learning-go-book-2e/money 
go 1.21 
require ( 
	github.com/learning-go-book-2e/formatter v0.0.0-20220918024742-18...
	github.com/shopspring/decimal v1.3.1
)
require ( 
	github.com/fatih/color v1.13.0 // indirect 
	github.com/mattn/go-colorable v0.1.9 // indirect 
	github.com/mattn/go-isatty v0.0.14 // indirect 
	golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c // indirect )
```

Каждый файл go.mod начинается с объявления модуля, которое включает в себя ключевое слово module и уникальный путь к модулю. Далее в директиве go указывается минимальная совместимая версия языка Go. Весь исходный код в модуле должен быть совместим с заданной версией. Например, если указать довольно старую версию 1.12, то компилятор не позволит использовать символы подчеркивания в числовых литералах, поскольку эта возможность была добавлена в Go 1.13.

### Директивы toolchain и переменной окружения GOTOOLCHAIN.

Им можно присвоить следующие значения: 
* auto — загружает более новые версии Go (это поведение по умолчанию в Go 1.21 и более поздних версиях); 
* local — восстанавливает поведение версий, предшествовавших Go 1.21; 
* в случае задания конкретной версии Go, например go1.20.4, она будет загружена и использована для сборки программы.

### Директива require

В этих директивах перечисляются модули, от которых зависит данный модуль, и указывается минимальная версия для каждого из них. Первая секция require перечисляет прямые зависимости модуля, вторая — зависимости зависимостей. Каждая строка в этой секции заканчивается комментарием // indirect. Функционально модули с такими комментариями и без них ничем не различаются, они служат лишь как документация для тех, кто будет просматривать файл go.mod.


### Компиляция пакетов
### Операции импорта и экспорта

В Go оператор import позволяет получить доступ к константам, переменным, функциям и типам, экспортируемым другим пакетом.

В Go для этого нет специального ключевого слова, а доступность идентификаторов за пределами пакета, в котором они объявляются, определяется по регистру символов. Если идентификатор начинается с буквы верхнего регистра, он экспортируемый, а если с буквы нижнего регистра или с символа подчеркивания, то будет доступен только внутри пакета, в котором объявлен

Все, что вы экспортируете, — это часть API вашего пакета. Прежде чем экспортировать идентификатор, убедитесь в том, что хотите предоставить клиентам доступ к нему. Документируйте все экспортируемые идентификаторы и следите за тем, чтобы они оставались обратно совместимыми при внесении изменений, если только вы не планируете намеренно внести значительные изменения в версию модуля

### Создание и использование пакета

``` go
package math 

func Double(a int) int { 
	return a * 2
}
```

Первая строка в этом файле содержит спецификатор пакета, который состоит из ключевого слова package и имени пакета. Первая непустая инезакомментированная строка любого файла исходного кода на языке Go содержит спецификатор пакета.

Каталог do-format содержит файл formatter.go со следующим кодом:

``` go
package format 

import "fmt" 

func Number(num int) string { 
	return fmt.Sprintf("The number is %d", num) 
}
```

Наконец, корневой каталог содержит файл main.go со следующим кодом:

``` go
package main 

import ( 
	"fmt" 
	
	"github.com/learning-go-book-2e/package_example/do-format" 
	"github.com/learning-go-book-2e/package_example/math" 
)

func main() { 
	num := math.Double(2) 
	output := format.Number(num) 
	fmt.Println(output) 
}
```

Имя пакета определяется его спецификатором, а не путем импорта.

Как правило, имя пакета совпадает с именем содержащего его каталога, поскольку в противном случае будет трудно выяснить, как называется пакет. Однако бывают ситуации, когда необходимо использовать имя пакета, отличающееся от имени каталога.

Имена пакетов должны быть описательными. Вместо такого имени, как util, пакету лучше дать имя, описывающее предоставляемую им функциональность.

Функция или метод что-то делает, поэтому ее/его имя должно быть глаголом, отражающим действие. Имя пакета должно быть существительным, описывающим что-то, что создается или изменяется функциями в пакете. 

Следуя этим правилам, можно создать пакет с именем names и двумя функциями, Extract и Format. Тогда первая будет называться names.Extract, а вторая — names.Format. 

Следует также избегать повторения имени пакета в именах функций и типов, определенных в этом пакете. Не стоит давать функции имя ExtractNames, если она определяется в пакете extract. Исключение из этого правила — случай, когда имя идентификатора совпадает с именем пакета. Например, в пакете sort стандартной библиотеки есть функция Sort, а в пакете context — интерфейс Context.

### Переопределение имени пакета

Если имена пакетов повторяются, вы можете переопределить их имена

``` go
import ( 
	crand "crypto/rand" 
	"encoding/binary" 
	"fmt" 
	"math/rand" 
)
```

### Комментарии пакета и Go Doc

У языка Go имеется формат для написания комментариев, автоматически преобразуемых в документацию. Он называется Go Doc и отличается исключительной простотой.

* Комментарий следует размещать непосредственно перед документируемым элементом, не оставляя пустых строк между комментарием и объявлением этого элемента. 
* В начале комментария должны стоять два символа косой черты (//), а за ними — имя элемента. Допускается также использовать блочные комментарии, заключенные в пары символов /* и */, но предпочтительнее комментарии, начинающиеся с двух символов косой черты.
* Комментарий с описанием функции, типа, константы, переменной или метода должен начинаться с описываемого идентификатора.
* Комментарии можно разбивать на абзацы с помощью пустого комментария.

Общедоступную документацию можно просматривать онлайн в формате HTML. Если вы хотите, чтобы ваши документы выглядели немного презентабельнее, используйте следующие приемы форматирования.

* Если хотите включить в комментарий предварительно отформатированное содержимое, например таблицу или исходный код, добавляйте дополнительные пробелы после начала комментария //, чтобы оформить отступы. 
* Чтобы оформить заголовок в комментарии, после // поставьте # и пробел. В отличие от разметки Markdown, формат Go Doc не позволяет использовать несколько символов # для создания заголовков разных уровней. 
* Чтобы создать ссылку на другой пакет (в текущем модуле или каком-то другом), заключите путь к пакету в квадратные скобки ([ и ]). Чтобы создать ссылку на экспортируемый символ, поместите его имя в квадратные скобки. Если символ находится в другом пакете, используйте префикс с именем пакета — [pkgName.SymbolName]. 
* Если включить в комментарий URL, он будет преобразован в ссылку. 
* Если хотите включить в ссылку на веб-страницу свой текст, то поместите его в квадратные скобки ([ и ]). В конце блока комментария объявите соответствия между вашим текстом и URL в формате // [ТЕКСТ]: URL. 

#### Комментарии уровня пакета 

``` go
// Пакет convert предоставляет различные утилиты с целью облегчить 
// конвертирование денежных сумм из одной валюты в другую 
package convert
```

#### Комментарий к структуре

``` go 
// Money содержит информацию о размере денежной суммы 
// и о том, в какой валюте она исчисляется 
//
// Значение хранится в поле типа [github.com/shopspring/decimal.Decimal] 
type Money struct { 
	Value decimal.Decimal 
	Currency string
}
```

#### Хорошо прокомментированная функция

``` go
// Convert конвертирует денежные суммы из одной валюты в другую. 
// 
// Эта функция принимает два параметра: экземпляр структуры Money, 
// содержащий преобразуемую сумму, и строку с названием валюты, в которую 
// производится пересчет. Convert возвращает сумму в указанной валюте 
// или ошибку, если валюта неизвестна или конвертирование в нее 
// не поддерживается. 
// 
// В случае ошибки возвращаемый экземпляр структуры Money 
// устанавливается в нулевое значение. 
// 
// Поддерживаются следующие валюты: 
// USD — доллар США 
// CAD — канадский доллар 
// EUR — евро 
// INR — индийская рупия 
// 
// Более подробные сведения о курсах обмена валют 
// можно найти на [Investopedia]. 
// 
// [Investopedia]: https://www.investopedia.com/terms/e/exchangerate.asp 
func Convert(from Money, to string) (Money, error) { 
	// ... 
}
```

В комплект поставки языка Go входит инструмент командной строки go doc, который позволяет просматривать комментарии Go Doc. Команда go doc ИМЯ_ПАКЕТА выводит комментарии Go Doc из указанного пакета и список имеющихся в нем идентификаторов. С помощью команды go doc ИМЯ_ПАКЕТА.ИМЯ_ИДЕНТИФИКАТОРА можно вывести документацию для определенного идентификатора в пакете. 

Для просмотра получившейся документации в формате HTML перед публикацией модуля в Интернете воспользуйтесь утилитой pkgsite.

``` txt
$ go install golang.org/x/pkgsite/cmd/pkgsite@latest
```