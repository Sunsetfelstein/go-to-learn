
Обобщенные типы уменьшают количество повторяющегося кода и повышают типобезопасность

``` go
type Stack[T any] struct { 
	vals []T 
} 

func (s *Stack[T]) Push(val T) { 
	s.vals = append(s.vals, val) 
} 

func (s *Stack[T]) Pop() (T, bool) { 
	if len(s.vals) == 0 { 
		var zero T 
		return zero, false 
	} 
	top := s.vals[len(s.vals)-1] 
	s.vals = s.vals[:len(s.vals)-1] 
	return top, true 
}
```

Прежде всего, после объявления типа указан параметр типа [T any]. Параметры типа заключают в квадратные скобки. Как и в обычных параметрах, сначала указывается имя, а следом — ограничение типа

Вторая интересная деталь — объявления методов. В них, как и в объявлении vals, используется тип T. В определениях приемника также указан тип Stack[T] вместо Stack. 

Третий любопытный момент — обработка нулевых значений. В методе Pop мы не можем просто вернуть nil, потому что это недопустимое значение для значимого типа, такого как int. Самый простой способ получить нулевое значение для обобщенного типа сводится к тому, чтобы просто объявить переменную с помощью ключевого слова var и вернуть ее, поскольку по определению ключевое слово var всегда инициализирует переменную соответствующим нулевым значением, если ей не присваивается другое значение.

### Сравнение

``` go
func (s Stack[T]) Contains(val T) bool { 
	for _, v := range s.vals { 
		if v == val { 
			return true 
		} 
	} return false 
}
```

К сожалению, этот код не скомпилируется, выдав сообщение об ошибке:

``` txt
invalid operation: v == val (type parameter T is not comparable with ==)
```

Как и пустой интерфейс interface{}, ограничение any ничего не сообщает о своем значении. Мы можем лишь добавлять и извлекать значения любого типа. Чтобы можно было использовать оператор  = =, мы должны задействовать другой тип. Поскольку почти все типы в Go поддерживают сравнение с помощью операторов == и !=, во всеобщем блоке был определен встроенный интерфейс comparable. Если мы заменим any на comparable в определении нашего типа Stack:

``` go
type Stack[T comparable] struct { 
	vals []T 
}
```

Это позволит использовать новый метод Contains.

#### В качестве ограничения типа можно использовать любой интерфейс, не только any и comparable

``` go
type Pair[T fmt.Stringer] struct { 
	Val1 T 
	Val2 T 
}
```

Есть также возможность определять интерфейсы, имеющие параметры типа

``` go
type Differ[T any] interface { 
	fmt.Stringer 
	Diff(T) float64 
}
```

Эти два типа можно использовать для создания функции сравнения, которая принимает два экземпляра Pair, имеющие поля типа Differ, и возвращает Pair с более близкими значениями:

``` go
func FindCloser[T Differ[T]](pair1, pair2 Pair[T]) Pair[T] { 
	d1 := pair1.Val1.Diff(pair1.Val2) 
	d2 := pair2.Val1.Diff(pair2.Val2) 
	if d1 < d2 { 
		return pair1 
	} 
	return pair2 
}
```

Обратите внимание на то, что FindCloser принимает экземпляры Pair, поля которых соответствуют интерфейсу Differ. Pair требует, чтобы оба поля были одного типа и чтобы тип соответствовал интерфейсу fmt.Stringer. Как следствие, эта функция более избирательна. Если поля в экземпляре Pair не соответствуют Differ, то компилятор не позволит использовать этот экземпляр с FindCloser.

#### Пример

``` go
type Point2D struct {
	X, Y int
}

func (p2 Point2D) String() string {
	return fmt.Sprintf("{%d,%d}", p2.X, p2.Y)
}

func (p2 Point2D) Diff(from Point2D) float64 {
	x := p2.X - from.X
	y := p2.Y - from.Y
	return math.Sqrt(float64(x*x) + float64(y*y))
}

type Point3D struct {
	X, Y, Z int
}

func (p3 Point3D) String() string {
	return fmt.Sprintf("{%d,%d,%d}", p3.X, p3.Y, p3.Z)
}

func (p3 Point3D) Diff(from Point3D) float64 {
	x := p3.X - from.X
	y := p3.Y - from.Y
	z := p3.Z - from.Z
	return math.Sqrt(float64(x*x) + float64(y*y) + float64(z*z))
}
```

### Списки типов

В случаях, когда необходимо указать типы для обобщения, которые, например, будут уметь выполнять операцию % (div) или деление, можно указать список типов в интерфейсе

``` go
type Integer interface { 
	int | int8 | int16 | int32 | int64 | 
		uint | uint8 | uint16 | uint32 | uint64 | uintptr 
}
```

Имейте в виду, что интерфейсы со списками типов могут использоваться только как ограничители типа. Применение их для обозначения типа переменной, поля, возвращаемого значения или параметра вызовет ошибку во время компиляции.

``` go
type MyInt int 
var myA MyInt = 10 
var myB MyInt = 20 
fmt.Println(divAndRemainder(myA, myB))
```

По умолчанию типы из списка должны точно совпадать с конкретным типом значения. Если попытаться применить функцию к значению пользовательского типа, основанного на типе, входящем в список в Integer, то компилятор сгенерирует ошибку.

``` txt 
MyInt does not satisfy Integer (possibly missing ~ for int in Integer)
```

Если вы хотите, чтобы список типов соответствовал любому пользовательскому типу, созданному на основе базового типа, входящего в список, поставьте перед типами в списке знак тильды (~)

Добавление списка типов позволяет определить тип, который даст возможность написать обобщенную функцию сравнения:

``` go
type Ordered interface { 
	~int | ~int8 | ~int16 | ~int32 | ~int64 | 
	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr | 
	~float32 | ~float64 | 
	~string 
}
```

Интерфейс Ordered перечисляет все типы, которые поддерживают операторы = =, !=, <, >, <= и >=. Возможность указать, что переменная представляет упорядочиваемый тип, настолько полезна, что в Go 1.21 добавлен пакет cmp, который определяет этот интерфейс Ordered. Пакет также определяет две функции сравнения. Функция Compare возвращает –1, 0 или 1, если первый параметр меньше второго, равен ему или больше него соответственно, а функция Less возвращает true, если первый параметр меньше второго.

Интерфейс, используемый как параметр типа, может перечислять не только допустимые типы, но и обязательные методы. Например, можно указать, что тип должен иметь базовый тип int и метод String() string:

``` go
type PrintableInt interface { 
	~int String() string 
}
```

Go позволяет объявлять интерфейсы для применения в качестве параметров типа, которые невозможно создать на самом деле. Если в PrintableInt использовать int вместо ~int, то ему не будет соответствовать допустимый тип, потому что у типа int нет методов. Такое поведение может показаться неправильным, но в случае чего компилятор придет вам на помощь. Если объявить тип или функцию с недопустимым параметром типа, то любая попытка его применения вызовет ошибку во время компиляции

### Списки типов накладывают ограничения на константы и реализации

Списки типов также определяют, какие константы могут присваиваться переменным обобщенного типа. Как и операторы, константы должны быть допустимыми для типов, перечисленных в списке.

Например, следующий код, использующий интерфейс Integer, не скомпилируется, потому что восьмиразрядному целому числу нельзя присвоить значение 1000:

``` go
// НЕ СКОМПИЛИРУЕТСЯ! 
func PlusOneThousand[T Integer](in T) T { 
	return in + 1_000 
}
```

### Что остается за бортом

Перегрузка операторов отсутствует в Go, а значит, вы не сможете применять ключевое слово range для обхода элементов в контейнерах пользовательского типа или квадратные скобки ([]) для доступа к ним по индексу. (Разработчики языка Go стремятся по возможности исключать проблемы с читабельностью кода)

За бортом исходной реализации обобщенных типов в Go осталась и такая полезная возможность, как использование параметров типа в методах.

К сожалению любителей функционального программирования, этот подход не работает. Вы не сможете составлять цепочки вызовов методов, и вам придется либо вкладывать вызовы функций друг в друга, либо использовать более читабельный подход с вызовом функций по отдельности и присваиванием промежуточных значений переменным.

Вы также не сможете определять функции с вариативными параметрами типа. В Go нет возможности указать для вариативных параметров какой-либо шаблон типа, такой как чередование string и int. Вариативные параметры должны соответствовать одному объявленному типу, который может быть обобщенным или нет. 

В Go не будут включены и следующие, гораздо менее распространенные средства обобщенного программирования. 
 * Специализация. В дополнение к обобщенной версии функцию или метод можно было бы перегружать одной или несколькими типоспецифичными версиями. Поскольку в Go нет перегрузки функций и методов, добавление этой возможности не планируется.
 * Каррирование (currying). Объявление функции или типа на основе другой обобщенной функции или типа с указанием только определенной части параметров.
 * Метапрограммирование. Определение кода, который выполняется на этапе компиляции, и генерирование кода, который, в свою очередь, выполняется на этапе выполнения

### Идиоматический Go-код и обобщенные типы

Добавление обобщенных типов вносит определенные коррективы в рекомендации по идиоматическому использованию языка Go. Это положит конец применению типа float64 для представления любых числовых типов. Мы больше не будем задействовать пустой интерфейс interface{} для представления значений любого типа, применяемых в структуре данных или в качестве параметров функции. Кроме того, теперь можно будет обрабатывать разные типы срезов с помощью одной функции.