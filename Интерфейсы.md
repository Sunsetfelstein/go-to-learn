### 1. Интерфейсы 

Интерфейсы — единственный абстрактный тип в Go

Набор методов экземпляра ссылочного типа содержит методы, получающие приемник и по указателю, и по значению, тогда как экземпляр значимого типа содержит только набор методов, получающий приемник по значению. Вот короткий пример использования структуры Counter, которая была определена ранее: 

``` go
type Incrementer interface { 
	Increment() 
} 

var myStringer fmt.Stringer 
var myIncrementer Incrementer 
pointerCounter := &Counter{} 
valueCounter := Counter{} 

myStringer = pointerCounter // ok 
myStringer = valueCounter // ok 
myIncrementer = pointerCounter // ok 
myIncrementer = valueCounter // ошибка компиляции!
```

- **Значение типа `T`** имеет методы с ресивером `T` (по значению)
- **Указатель типа `*T`** имеет методы с ресиверами `T` и `*T` (и по значению, и по указателю)

Это потому, что Go автоматически разыменовывает указатели при вызове методов.

### 2. Интерфейсы обеспечивают типобезопасную утиную типизацию

Интерфейсы реализуются неявным образом. Конкретный тип не объявляет о том, что он реализует интерфейс. Если набор методов конкретного типа содержит все методы из набора методов интерфейса, то этот конкретный тип реализует интерфейс. Это означает, что экземпляр этого конкретного типа можно присвоить переменной или полю с типом указанного интерфейса.

«Программируйте на уровне интерфейса, а не на уровне реализации». В таком случае вы будете зависеть только от поведения, а не от реализации, что позволит при необходимости заменить одну реализацию на другую. Это делает возможным дальнейшее совершенствование кода по мере неизбежного изменения требований.

Утиная типизация, в основе которой лежит следующий принцип: «Если что-то ходит и крякает как утка, то это утка»

### 3. Принимайте интерфейсы, возвращайте структуры

Это означает, что выполняемая функциями бизнес-логика должна вызываться посредством интерфейсов, а результаты функций должны представлять собой конкретные типы. Функции должны принимать интерфейсы по причине того, что они делают код более гибким и явно объявляют, какая именно функциональность используется в функции.

Главная причина, почему ваши функции должны возвращать конкретные типы, — они упрощают последующее изменение этих типов в новых версиях кода. Когда функция возвращает конкретный тип, вы можете добавлять в него новые методы и поля, не нарушая работу существующего кода. Но это не относится к интерфейсам. После добавления нового метода в интерфейс придется обновить все существующие его реализации, иначе работа вашего кода нарушится. Здесь можно провести аналогию c семантическим управлением версиями, когда при изменении младшего номера версии гарантируется сохранение обратной совместимости, а при изменении старшего номера версии обратная совместимость нарушается. Если ваш API применяют другие люди внутри вашей организации или как часть проекта с открытым исходным кодом, сохранение обратной совместимости избавит пользователей от лишних хлопот.

Возврат структуры позволяет обойтись без выделения памяти в куче, и это очень хорошо. Однако при вызове функции с параметрами интерфейсного типа каждый из них размещается в куче. По мере развития программы вам нужно будет найти оптимальный баланс между степенью абстракции и производительностью. Прежде всего старайтесь сделать свой код читабельным и легко сопровождаемым. Если ваша программа работает слишком медленно и профилирование показывает, что причиной низкой производительности является выделение памяти в куче для параметра интерфейсного типа, перепишите функцию так, чтобы она использовала параметр конкретного типа. Когда в функцию передается несколько реализаций интерфейса, создайте несколько функций с повторяющейся логикой.

### 4. Интерфейсы и значение nil

В среде выполнения Go интерфейсы реализованы как структура с двумя полями-указателями: один служит ссылкой на значение, а другой — на тип значения. Пока поле типа не равно nil, интерфейс не равен nil. (Поскольку переменная всегда имеет определенный тип, если ссылка на значение не равна nil, то и ссылка на тип не будет равна nil.) Интерфейс считается равным nil в том случае, когда оба указателя, ссылающиеся на значение и тип, равны nil.

``` go
var pointerCounter *Counter 
fmt.Println(pointerCounter == nil) // выведет true 
var incrementer Incrementer fmt.Println(incrementer == nil) // выведет true
incrementer = pointerCounter fmt.Println(incrementer == nil) // выведет false
```

Так как теперь в интерфейсе Increment указатель на тип значения теперь Counter, то интерфейс теперь != nil, это может привести к паникам.

Поскольку экземпляр интерфейса со ссылкой на тип, не равной nil, сам не равен nil, очень сложно определить, равно ли nil связанное с интерфейсом значение. Чтобы выяснить это придется задействовать рефлексию.


### 5. Если переменная может содержать значение любого типа

В Go для этой цели предназначен пустой интерфейс interface{}:

``` go
var i interface{} 
i = 20 
i = "hello" 
i = struct { 
	FirstName string 
	LastName string
} {"Fred", "Fredson"}
```

Для большей удобочитаемости в Go было добавлено ключевое слово any как псевдоним interface{}.

В частности, any широко используется в качестве заглушки для данных снеопределенной схемой размещения, получаемых из внешних источников, таких как файлы вформате JSON: 

``` go
data := map[string]any{} 
contents, err := os.ReadFile("testdata/sample.json") 
if err != nil { 
	return err 
} 
json.Unmarshal(contents, &data) // содержимое переменной contents теперь находится в отображении data
```

Когда функция принимает пустой интерфейс, для записи или чтения значений она, как правило, использует рефлексию. Так, в приведенном ранее примере второй параметр функции json.Unmarshal объявлен с типом any.

Поскольку такие ситуации случаются редко, старайтесь избегать any. Как уже говорилось, Go — язык со строгой типизацией, и попытки обойти эту его особенность противоречат идиоматическому подходу.

### 6. Утверждения типа

Утверждение типа определяет конкретный тип, реализующий данный интерфейс, или другой интерфейс, который также реализуется базовым конкретным типом интерфейса, значение которого хранится в исследуемой переменной.

``` go
type MyInt int 

func main() { 
	var i any 
	var mine MyInt = 20 
	i = mine 
	i2 := i.(MyInt) // утверждение типа
	fmt.Println(i2 + 1) 
}
```

### Type Conversion (приведение типа):

``` go
var x int = 10
var y float64 = float64(x)  // Приведение int к float64
```
### Type Assertion (утверждение типа):

``` go
var i any = 10
var x int = i.(int)  // Утверждение, что i содержит int
```

Между операциями утверждения типа и преобразования типа существенная разница. Операции преобразования типа могут применяться и к конкретным типам, и к интерфейсам и проверяются **на этапе компиляции**. Операции утверждения типа могут применяться только к интерфейсным типам и проверяются **на этапе выполнения программы**. Поскольку проверка проводится на этапе выполнения, они могут вызвать сбой программы. Операции преобразования типа меняют тип, а операции утверждения типа его раскрывают.

Идиома Запятая, ok

``` go 
i2, ok := i.(int) 
if !ok { 
	return fmt.Errorf("unexpected type for %v",i) 
} 
fmt.Println(i2 + 1)
```

### 7. Переключатели типа 

Когда в качестве интерфейса может выступать один из нескольких возможных типов, вместо утверждения следует применять переключатель типа:

``` go
func doThings(i any) { 
	switch j := i.(type) { 
		case nil: 
			// переменная i равна nil, переменная j имеет тип any 
		case int: 
			// переменная j имеет тип int 
		case MyInt: 
			// переменная j имеет тип MyInt 
		case io.Reader: 
			// переменная j имеет тип io.Reader 
		case string: 
			// переменная j имеет тип string 
		case bool, rune: 
			// переменная i содержит булево значение или руну, 
			// поэтому переменная j имеет тип any 
		default: 
			// неизвестно, что содержит переменная i, поэтому переменная j 
			// имеет тип any 
	} 
}
```


## Примеры:

### Хранение логов

Давайте рассмотрим реалистичный пример. Большая часть приложений, особенно серверных, порождает логи. Как вы знаете, логи могут пригодиться при выяснении причин отказа сервиса или помочь в исправлении багов. Поэтому скорее всего вы, либо команда инфраструктуры, либо команда эксплуатации, либо кто-то ещё заинтересован в том, чтобы логи можно было сохранить в постоянное хранилище, т.к. стандартные поток вывода и поток ошибок для этого не подходят. Обычно роль такого хранилища на себя берет либо файл на диске, либо специальный внешний сервис. При этом не хочется, чтобы компоненты, использующие логгер по прямому назначению были в курсе или как-то влияли на этот аспект. В этот момент на сцене появляется `io.Writer`.

И логгер из стандартной библиотеки, и многие сторонние библиотеки позволяют настраивать вывод логов. В большинстве случаев для этого логгеру можно передать реализацию `Writer`. `os.File`, как мы выяснили раньше, реализует `Writer`, как и `os.Stdout` с `os.Stderr`:

``` go 
f, err := os.Open("<path-to-file>")
if err != nil {
	return err
}
defer f.Close()

log.Default().SetOutput(f)

log.Println("hello, world!")
```

В пакете `io` также присутствует полезная функция `MultiWriter` возвращающая `Writer`, построенный из нескольких других `Writer`:

``` go 
f, err := os.Open("<path-to-file>")
if err != nil {
	return err
}
defer f.Close()

mw := io.MultiWriter(f, os.Stdout)

log.Default().SetOutput(mw)

log.Println("hello, world!")
```

## Хранилище данных

Современные информационные системы поставляются со сложными хранилищами данных, для администрирования которых обычно отдельно выделяют человеческие ресурсы. Разворачивать такие хранилища на локальной машине разработчика часто бывает неоправданно долго, сложно и ресурсоёмко. Поэтому в таких случаях используют либо похожее, но облегчённое хранилище, либо вовсе хранят данные в памяти. Например, на сервере приложение может использовать PostgreSQL, а на машине разработчика SQLite. Это первая причина, по которой интерфейсы могут пригодиться для описания хранилища данных.

Вторая причина заключается в тезисе, который звучал ранее немного в другом виде: компонентам, использующим хранилище не важны специфические детали, относящиеся к источнику данных. Т.е., например, слою приложения, в котором содержится бизнес-логика над пользователями не должно быть важно, где эти самые пользователи хранятся. Главное, чтобы была возможность исполнять определённый набор операций над этой сущностью. Обратная ситуация называется протеканием абстракции, но это уже тема для отдельного материала.

Также при написании тестов на код, использующий хранилище или внешнюю службу не всегда целесообразно обращаться к реальной базе данных или API. Вместо этого можно создать _мок_ (mock) — хранилище-заглушку, которое обладает тем же набором методов, что и реальное, но оперирует оно над фейковыми данными. При использовании интерфейсов провернуть такой трюк сильно проще.