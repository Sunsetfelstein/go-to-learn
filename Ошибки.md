
Обработка ошибок в Go сводится к возврату значения типа error в качестве последнего возвращаемого значения функции. Это общепринятое соглашение, которое соблюдается настолько строго, что его никогда не следует нарушать. Когда функция выполняется ожидаемым образом, в качестве параметра ошибки возвращается значение nil. Если что-то идет не так, вместо этого возвращается значение ошибки. После этого вызывающая функция проверяет возвращаемое значение ошибки, сравнивая его со значением nil, и обрабатывает ошибку или возвращает некоторую собственную ошибку

``` go
func calcRemainderAndMod(numerator, denominator int) (int, int, error) { 
	if denominator == 0 { 
		return 0, 0, errors.New("denominator is 0")
	} 
	return numerator / denominator, numerator % denominator, nil 
}
```

Новая ошибка создается из строки путем вызова функции New из пакета errors. Сообщения об ошибке не должны начинаться с большой буквы и заканчиваться знаком пунктуации или символом новой строки. В большинстве случаев при возврате ненулевой ошибки остальным возвращаемым значениям следует присвоить соответствующие нулевые значения. 

Исключение из этого правила — возврат сигнальных ошибок.

В отличие от языков с исключениями, в Go нет специальных конструкций для выявления случаев, когда возвращается ошибка. Всякий раз, когда функция возвращает значения, используйте оператор if, чтобы проверить, не является ли параметр ошибки ненулевым:

``` go
func main() { 
	numerator := 20 
	denominator := 3 
	remainder, mod, err := calcRemainderAndMod(numerator, denominator) 
	
	if err != nil { 
		fmt.Println(err) 
		os.Exit(1) 
	} 
	
	fmt.Println(remainder, mod) 
}
```

### Тип error 

Это встроенный интерфейс, который определяет метод:

``` go
type error interface { 
	Error() string 
}
```

Любой тип, который реализует этот интерфейс, считается ошибкой.

Есть две веские причины, по которым в Go принято возвращать ошибки, а не генерировать исключения. Во-первых, исключения добавляют как минимум один дополнительный путь выполнения кода. Эти пути выполнения кода иногда бывают неясными, особенно в языках, в которых функции не содержат объявление о возможности исключения. В результате вы можете получить код, который будет неожиданно прекращать работу в случае неправильной обработки исключений или, что еще хуже, продолжать работу после некорректного выполнения инициализации, модификации или сохранения данных. 

Вторая причина носит не столь явный характер, но показывает, насколько хорошо различные элементы языка Go согласуются друг с другом. Компилятор языка Go требует, чтобы все объявленные переменные были прочитаны. В силу того что ошибки являются возвращаемыми значениями, разработчикам приходится либо проверять наличие состояний ошибки и обрабатывать их, либо явно указывать, что ошибки будут игнорироваться, используя в качестве возвращаемого значения ошибки символ подчеркивания (_).

### Строки в случае простых ошибок

Использование errors.New

``` go
func doubleEven(i int) (int, error) { 
	if i % 2 != 0 { 
		return 0, errors.New("only even numbers are processed") 
	} 
	return i * 2, nil 
}

func main() { 
	result, err := doubleEven(1) 
	if err != nil { 
		fmt.Println(err) // выведет: "only even numbers are processed" 
	} 
	fmt.Println(result) 
}
```

Использование fmt.Errorf, которая позволяет включить в сообщение об ошибке информацию о сфере выполнения с помощью глаголов форматирования функции fmt.Printf. Как и при использовании функции errors.New, эта строка возвращается при вызове метода Error для возвращаемого экземпляра ошибки.

``` go
func doubleEven(i int) (int, error) { 
	if i % 2 != 0 { 
		return 0, fmt.Errorf("%d isn't an even number", i) 
	} 
	return i * 2, nil 
}
```

### Сигнальные ошибки (Sentinel Error)

В некоторых случаях ошибка должна сигнализировать о том, что обработка не может продолжаться из-за проблемы с текущим состоянием.

«Это название происходит от существующей в программировании практики использования определенного значения для обозначения невозможности какой-либо дальнейшей обработки. Так же и в Go мы применяем определенные значения для обозначения ошибки».

Сигнальные ошибки относятся к числу тех немногих разновидностей переменных, которые могут объявляться на уровне пакета.

В соответствии с общепринятым соглашением их имена начинаются на Err (io.EOF — важное исключение)

Они должны обрабатываться как данные, доступные только для чтения. Хотя компилятор языка Go никак это не ограничивает, но модификация сигнальной ошибки считается программной ошибкой.

Если нужно сообщить, что приложение достигло состояния, при котором дальнейшее выполнение невозможно, и нет необходимости использовать контекстную информацию для объяснения состояния ошибки, то сигнальная ошибка будет правильным выбором.

 Объявляются как глобальные переменные (`var EOF = errors.New(...)`)
 

``` go
package io

var EOF = errors.New("EOF") // Сигнальная ошибка

// Использование
buf := make([]byte, 1024)
n, err := r.Read(buf)
if err == io.EOF {
    // Достигнут конец файла
}
```


### Пользовательская реализация Error

Поскольку тип error представляет собой интерфейс, вы можете определить собственные ошибки с дополнительной информацией для целей журналирования или обработки ошибок. Например, иногда в ошибку требуется включить код состояния, чтобы указать, какое сообщение выдать пользователю. Это позволяет вам при определении причин ошибки обойтись без сравнения строк, содержимое которых может измениться.

``` go
type Status int

const (
    InvalidLogin Status = iota + 1
    NotFound
)

type StatusErr struct {
    Status  Status
    Message string
}

func (se StatusErr) Error() string {
    return se.Message
}

func LoginAndGetData(uid, pwd, file string) ([]byte, error) {
    token err := login(uid, pwd)
    if err != nil {
        return nil, StatusErr{
            Status: InvalidLogin,
            Message: fmt.Sprintf("invalid credentials for user %s", uid),
        }
    }
    data, err := getData(token, file)
    if err != nil {
        return nil, StatusErr{
        Status: NotFound,
        Message: fmt.Sprintf("file %s not found", file),
        }
    }
    return data, nil
}
```

Даже если вы определяете собственные пользовательские типы ошибок, всегда применяйте тип error в качестве типа возвращаемой ошибки. Это позволит возвращать из функции разные типы ошибок, а вызывающая сторона при этом не будет зависеть от конкретного типа ошибок.

При возврате ошибок следует возвращать или инициализированный экземпляр, или nil, поскольку, если вернуть неинициализированный экземпляр, например, var genErr StatusErr, вернется не nil, так как чтобы интерфейс считался равным nil, значению nil должны быть равны и базовый тип, и базовое значение.

Для доступа к полям и методам пользовательской ошибки не следует применять утверждения типа и переключатели типа. Вместо этого задействуйте функцию errors.As

### Обертывание ошибок

Когда ошибка передается в коде в обратном направлении, часто в нее требуется внести дополнительный контекст. Этим контекстом может быть имя функции, в которой произошла ошибка, или сведения о том, какую операцию она пыталась при этом выполнить. Если при добавлении информации исходная ошибка сохраняется, это называют обертыванием ошибки. Последовательность обернутых ошибок называется цепью ошибок.

Функция fmt.Errorf поддерживает специальный глагол %w для создания уточненного сообщения об ошибке, содержащего исходную ошибку.

``` go
func fileChecker(name string) error { 
	f, err := os.Open(name) 
	if err != nil { 
		return fmt.Errorf("in fileChecker: %w", err) 
	} 
	f.Close() 
	return nil
} 

func main() { 
	err := fileChecker("not_here.txt") 
	if err != nil { 
		fmt.Println(err) 
		if wrappedErr := errors.Unwrap(err); wrappedErr != nil {
			fmt.Println(wrappedErr)
		} 
	} 
}
```

``` txt
in fileChecker: open not_here.txt: no such file or directory open not_here.txt: no such file or directory
```

Если вы хотите обернуть ошибку в свой пользовательский тип, ваш тип ошибки должен реализовывать метод Unwrap. Он не принимает параметров и возвращает значение типа error.

``` go
type StatusErr struct { 
	Status Status 
	Message string 
	Err error 
} 

func (se StatusErr) Error() string { 
	return se.Message 
} 

func (se StatusError) Unwrap() error { 
	return se.err 
}
```

Не все ошибки нуждаются в обертке. Иногда библиотека возвращает ошибку, которая означает невозможность выполнения дальнейшей обработки, но сообщение об ошибке при этом содержит детали, которые не требуются в других частях программы. В таком случае лучше создать совершенно новую ошибку и возвращать ее, не прибегая к обертыванию. Старайтесь всегда возвращать то, что требуется в конкретном случае.

Если вы хотите создать новую ошибку, которая содержала бы сообщение из другой ошибки, не обертывая ее при этом, создайте ошибку с помощью функции fmt.Errorf, используя глагол %v вместо %w:

``` go
err := internalFunction() if err != nil { 
	return fmt.Errorf("internal failure: %v", err) 
}
```

### Возвращение нескольких ошибок

Использование errors.Join

``` go
type Person struct { 
	FirstName string 
	LastName string 
	Age int 
} 

func ValidatePerson(p Person) error { 
	var errs []error 
	if len(p.FirstName) == 0 { 
		errs = append(errs, errors.New("field FirstName cannot be empty")) 
	} 
	if len(p.LastName) == 0 { 
		errs = append(errs, errors.New("field LastName cannot be empty")) 
	} 
	if p.Age < 0 { 
		errs = append(errs, errors.New("field Age cannot be negative")) 
	} 
	if len(errs) > 0 { 
		return w
	} 
	return nil 
}
```

Другой способ объединить несколько ошибок — передать несколько глаголов %w в fmt.Errorf:

``` go 
err1 := errors.New("first error") 
err2 := errors.New("second error") 
err3 := errors.New("third error") 
err := fmt.Errorf("first: %w, second: %w, third: %w", err1, err2, err3)
```

При желании можно реализовать свой тип error, поддерживающий обертывание нескольких ошибок. Для этого достаточно реализовать метод Unwrap, возвращающий []error вместо error:

``` go
type MyError struct {
	Code int 
	Errors []error
}

func (m MyError) Error() string { 
	return errors.Join(m.Errors...).Error() 
} 

func (m MyError) Unwrap() []error { 
	return m.Errors 
}
```

Go не поддерживает перегрузку методов, поэтому вы не сможете создать один тип с обеими реализациями Unwrap. Обратите также внимание, что функция errors.Unwrap вернет nil, если передать ей ошибку, реализующую вариант Unwrap, возвращающий []error. Это еще одна причина, почему не следует вызывать функцию error.Unwrap напрямую.

``` go
var err error 
err = funcThatReturnsAnError() 
switch err := err.(type) { 
	case interface {Unwrap() error}: 
		// обработка единственной ошибки 
		innerErr := err.Unwrap() 
		// обработать innerErr 
	case interface {Unwrap() []error}: 
		// обработка нескольких обернутых ошибок 
		innerErrs := err.Unwrap() 
		for _, innerErr := range innerErrs { 
			// обработать каждую innerErr 
		} 
	default: 
		// обработка обычной, не обернутой ошибки 
}
```

### Функции Is и As

Обертывание ошибок дает удобный способ передачи дополнительной информации, но в то же время создает определенные проблемы. Вы не сможете проверить наличие сигнальной ошибки с помощью оператора = =, равно как и применить утверждение типа или переключатель типа к пользовательской ошибке, если она будет обернута.
#### Функция errors.Is

Чтобы проверить, не совпадает ли возвращаемая ошибка или какая-либо из завернутых в нее ошибок с определенным экземпляром сигнальной ошибки, следует использовать функцию errors.Is. Функция errors.Is возвращает значение true, если в цепи ошибок присутствует ошибка, совпадающая с указанной сигнальной ошибкой.

``` go
func fileChecker(name string) error {
	f, err := os.Open(name)
	if err != nil {
		return fmt.Errorf("in fileChecker: %w", err)
	}
	f.Close()
	return nil
}

func main() {
	err := fileChecker("not_here.txt")
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			fmt.Println("That file doesn't exist")
		}
	}
}
```

По умолчанию сравнивает каждую из обернутых ошибок с указанной ошибкой с помощью оператора = =. Если это не подходит для определенного вами типа ошибки (например, если ваша ошибка является несравниваемым типом), реализуйте метод Is для своей ошибки:

``` go
type MyErr struct { 
	Codes []int 
} 

func (me MyErr) Error() string { 
	return fmt.Sprintf("codes: %v", me.Codes) 
} 

func (me MyErr) Is(target error) bool { 
	if me2, ok := target.(MyErr); ok { 
		return slices.Equal(me.Codes, me2.Codes) 
	}
	return false 
}
```

#### Функция errors.As

Позволяет проверить совпадение возвращаемой ошибки (или любой ошибки, завернутой в нее) с определенным типом. Эта функция принимает два параметра: проверяемую ошибку и указатель на переменную искомого типа. Она возвращает значение true при наличии в цепи ошибок совпадающей ошибки, которая затем присваивается второму параметру. При отсутствии совпадений в цепи ошибок возвращается значение false.

``` go 
type MyErr struct {
	Codes []int
}

func (me MyErr) CodeVals() []int {
	return me.Codes
}

func (me MyErr) Error() string {
	return fmt.Sprintf("codes: %v", me.Codes)
}

func AFunctionThatReturnsAnError() error {
	return MyErr{Codes: []int{1, 1, 2, 3, 5, 8}}
}

func main() {
	err := AFunctionThatReturnsAnError()
	var myErr MyErr
	if errors.As(err, &myErr) {
		fmt.Println(myErr.Codes)
	}

	var coder interface {
		CodeVals() []int
	}
	if errors.As(err, &coder) {
		fmt.Println(coder.CodeVals())
	}
}
```

Функция errors.As сгенерирует панику, если во втором параметре передать ей не указатель на ошибку или интерфейс, а что-то иное.

По аналогии с возможностью переопределить стандартную функцию errors.Is с помощью своего метода Is есть возможность переопределить и стандартную функцию errors.As, определив для своей ошибки метод As. Реализация метода As является нетривиальной задачей и требует применения рефлексии. Прибегать к этому следует в исключительных случаях, например, когда требуется выявлять ошибку одного типа и возвращать ошибку другого типа.

#### Используйте функцию errors.Is, когда требуется выявить определенный экземпляр или определенные значения. Если же нужно выявить определенный тип, примените errors.As.

### Обертывание ошибок с помощью оператора defer

``` go
func DoSomeThings(val1 int, val2 string) (_ string, err error) { 
	defer func() { 
		if err != nil { 
		err = fmt.Errorf("in DoSomeThings: %w", err) 
		} 
	}() 
	
	val3, err := doThing1(val1) 
	if err != nil { 
		return "", err 
	} 
	val4, err := doThing2(val2) 
	if err != nil { 
		return "", err 
	} 
	return doThing3(val3, val4) }
```


### Функции panic и recover

Когда среда выполнения оказывается в ситуации, когда она не знает, что делать дальше, она генерирует панику. 

Паника сразу завершает работу кода и вызывает отложенные функции, пока не дойдет до main. 

После этого происходит выход из программы с выводом сообщения.

Если паника была вызвана в горутине, то вызов отложенных функций оборвет на функции, в которой горутина была создана. Если горутина генерирует панику и не пытается восстановиться после нее, то программа завершает работу.

Панику можно выловить с помощью defer. Для этого нужно вызвать recover и проверить, были ли сгенерирована паника. При наличии паники возвращается присвоенное ей значение. После выполнения функции recover работа продолжается как обычно.

``` go
func div60(i int) {
	defer func() {
		if v := recover(); v != nil {
			fmt.Println(v)
		}
	}()
	fmt.Println(60 / i)
}

func main() {
	for _, val := range []int{1, 2, 0, 6} {
		div60(val)
	}
}
```

Это напоминает обработку исключений в других языках, но он не предназначены для этого.
В представленном ранее примере кода идиоматический подход сводится к тому, чтобы проверить, не выполняется ли деление на ноль, и вернуть ошибку, если функции был передан ноль.

Применять recover следует лишь в одной ситуации, когда вы пишите публичный API, и чтобы не распространять панику за пределы API, обрабатывайте ее и оборачивается в Error, чтобы позволить вызывающему коду обработать ее по своему усмотрению



