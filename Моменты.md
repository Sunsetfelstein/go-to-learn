#### 1. Append у среза

Когда длина становится равной емкости, в срезе не остается места для размещения новых значений. В этом случае при попытке добавить новые значения функция append даст указание среде выполнения языка Go выделить новый резервный массив для среза большей емкости.

При увеличении среза с помощью функции append среде выполнения языка Go требуется некоторое время на то, чтобы выделить новую область памяти и скопировать в нее данные из старой области памяти. Нужно также освободить старую область памяти с помощью сборки мусора. Из-за этого каждый раз, когда емкость среза становится недостаточной, среда выполнения языка Go увеличивает ее сразу на несколько единиц. Начиная с версии Go 1.18, действует следующее правило: емкость среза увеличивается в два раза, если текущая емкость меньше 256. Больший фрагмент увеличивается на (current_capacity + 768)/4. Это медленно приводит к увеличению на 25 % (срез емкостью 512 увеличится на 63 %, а срез емкостью 4096 — только на 30 %)
#### 2. Массивы и срезы

В случае взятия среза в массиве новый срез будет точно так же использовать общую память, как и в случае взятия среза в срезе. 
``` go
x := [4]int{5, 6, 7, 8} y := x[:2]
```

При преобразовании среза в массив данные из него копируются в новую память.
``` go
xSlice := []int{1, 2, 3, 4} 
xArray := [4]int(xSlice)
```

Вы также можете использовать преобразование типов для преобразования среза в указатель на массив:
``` go
 xSlice := []int{1,2,3,4} 
 xArrayPointer := (*[4]int)(xSlice)
```

После преобразования среза в указатель массива память между ними становится общей. Изменение одного из них приведет к изменению другого:
``` go
 xSlice[0] = 10 
 xArrayPointer[1] = 20 fmt.Println(xSlice) // выводит [10 20 3 4]
 fmt.Println(xArrayPointer) // выводит &[10 20 3 4]
```
#### 3.  Получение значения из строки по индексу 

``` go
var s string = "Hello there" 
var b byte = s[6]
```

Как и массивы и срезы, индексы строк отсчитываются от 0. В данном примере байту b присваивается числовое значение седьмой позиции строки s, то есть 116 (значение строчной буквы t в формате UTF-8).

Поскольку строки неизменяемые, они избавлены от проблем с модификацией элементов, свойственных срезам срезов. Однако у них есть другая проблема: в то время как строка представляет собой последовательность байтов, размер кодовой точки в кодировке UTF-8 может составлять от 1 до 4 байт. В предыдущем примере все сработало, как ожидалось, потому что мы использовали исключительно кодовые точки кодировки UTF-8, длина которых равна 1 байту. Однако, работая с текстами на других языках, помимо английского, или с символами эмоций, вы будете иметь дело с кодовыми точками кодировки UTF-8, длина которых составляет больше 1 байта:

![[Pasted image 20260101111848.png]]

Хоть язык Go и позволяет использовать со строками синтаксис взятия среза и обращения по индексу, эти возможности следует применять лишь тогда, когда точно известно, что строка содерCжит только однобайтовые символы

### 4. Map, HashTable, Set, Словари

Это отображение: 

``` go
m := map[string]int{ 
	"hello": 5, 
	"world": 0, 
} 
v, ok := m["hello"]
```

### 5. Инициализация структур 

``` go
type person struct { 
	name string
	age int
	pet string 
}

julia := person{ 
	"Julia",
	40, 
	"cat", 
}

beth := person{ 
	age: 30,
	name: "Beth",
}
```

Для небольших структур, у которых всегда указываются имена всех полей, будет вполне уместным более простой стиль записи. Во всех остальных случаях лучше использовать имена. Хотя этот стиль более многословен, он позволяет четко указать, какое значение присваивается какому полю, не сверяясь с определением структуры. Кроме того, литерал структуры в таком формате проще поддерживать. Если вы будете инициализировать структуру, не используя имена полей, то добавление в нее дополнительных полей в одной из новых версий программы приведет к ошибке при компиляции.

Если все поля структуры относятся к сравниваемым типам, то и сама структура является сравниваемой.

### 6. Анонимная структура 

``` go
var person struct { 
	name string
	age int 
	pet string 
}
person.name = "bob"
person.age = 50 
person.pet = "dog" 
pet := struct { 
	name string 
	kind string 
}{
	name: "Fido",
	kind: "dog", 
}
```

Анонимные структуры удобно использовать в двух распространенных случаях. Первым является преобразование внешних данных в структуру или, наоборот, структуры во внешние данные, например данные в формате JSON или буферы протоколов. Эти виды преобразований называют маршалингом и демаршалингом данных соответственно.
Второй областью применения анонимных структур является написание тестов.

### 7. Приведение одной структуры к другой

Подобно тому как в Go нельзя сравнивать переменные, относящиеся к разным простым типам, в этом языке невозможно сравнивать и переменные, относящиеся к разным структурным типам. В то же время в Go доступно преобразование из одного структурного типа в другой, если поля обеих структур имеют одинаковые имена и типы и расположены в одном и том же порядке

У анонимных структур здесь имеется небольшая дополнительная особенность: если из двух переменных структурного типа как минимум одна относится к анонимному структурному типу, то их можно сравнивать без преобразования типов, если поля обеих структур имеют одинаковые имена и типы и расположены в одном и том же порядке. Вы также можете выполнять присваивание между переменными именованного и анонимного структурных типов, если поля обеих имеют одинаковые имена и типы и расположены в одинаковом порядке

### 8. Затенение переменных 

``` go
func main() { 
	x := 10 
	if x > 5 { 
		fmt.Println(x) // 10
		x := 5 
		fmt.Println(x) // 5
	} 
	fmt.Println(x) // 10
}
```

Переменная является затеняющей, если ее имя совпадает с именем переменной, определенной во вмещающем блоке. При наличии затеняющей переменной вы не можете получить доступ к затененной переменной.

Никогда не допускайте переопределения идентификаторов, определенных во всеобщем блоке! Если вы случайно это сделаете, код будет вести себя совсем не так, как вы ожидали. В лучшем случае это приведет к ошибкам на этапе компиляции. В более тяжелом случае придется долго выискивать источник своих проблем.

### 9. Обход элементов отображения 

``` go
m := map[string]int{ 
	"a": 1, 
	"c": 3, 
	"b": 2, 
}
for i := 0; i < 2; i++ { 
	fmt.Println("Loop", i) 
	for k, v := range m { 
		fmt.Println(k, v) 
	} 
}

/*
Loop 0 
c 3 
b 2 
a 1 
Loop 1 
a 1 
c 3 
b 2 
*/
```

Порядок ключей и значений будет меняться, иногда повторяясь. На самом деле такое поведение обусловлено соображениями безопасности. В более ранних версиях языка Go порядок обхода ключей у отображений с одинаковыми элементами обычно (но не всегда) был одинаковым. Это порождало две проблемы:

* Разработчики писали код с расчетом на фиксированный порядок обхода, но он иногда приводил к сбоям в самый неподходящий момент. 
* Если отображение всегда хеширует элементы в одни и те же значения и злоумышленнику известно, что сервер сохраняет пользовательские данные в виде отображения, то можно добиться реального замедления работы сервера с помощью DdoS-атаки на основе хеш-коллизий (Hash DoS), отправив серверу специально подготовленные данные, все ключи которых хешируются в одно и то же ведро. 

Чтобы устранить обе эти проблемы, разработчики языка Go внесли два изменения в реализацию отображения. Во-первых, они модифицировали хеш-алгоритм для отображений таким образом, чтобы при каждом создании переменной отображения генерировалось случайное число. Во-вторых, они сделали так, чтобы при каждом обходе отображения с помощью цикла for-range порядок обхода элементов немного варьировался. Эти два изменения существенно усложнили проведение DoS-атаки на основе хеш-коллизий

Из этого правила есть одно исключение. Чтобы упростить процесс отладки и ведение журналов отображений, функции форматирования, такие как fmt.Println, всегда выводят отображения в порядке возрастания ключей.

### 10. for-range для строк

``` go
for i, r := range "apple_π!" {
        fmt.Println(i, r, string(r))
    }
    
/*
0 97 a
1 112 p
2 112 p
3 108 l
4 101 e
5 95 _
6 960 π
8 33 !
*/    
```

Этот цикл перебирает руны, а не байты. Всякий раз, когда цикл for-range встречает в строке руну из нескольких байтов, он преобразует это представление в формате UTF-8 в одно 32-разрядное число и присваивает его переменной. Смещение при этом увеличивается на то количество байтов, которое содержится в руне. Когда цикл for-range встречает байт, который не является одним из допустимых значений в формате UTF-8, вместо него возвращается символ подстановки Unicode (шестнадцатеричное значение 0xfffd).

Используйте цикл for-range для последовательного доступа к рунам в строке. Первая переменная содержит количество байтов от начала строки, а вторая переменная относится к рунному типу.

### 11. Цикл for-range копирует значения элементов

Изменение значения переменной не приведет к изменению соответствующего значения в составном типе

В Go 1.22 или более поздней версии, если в директиве go указано значение 1.22 или выше, цикл for будет создавать новые переменные с индексом и значением в каждой итерации

### 12. Использование меток 

``` go
    samples := []string{"hello", "apple_π!"}
outer:
    for _, sample := range samples {
        for i, r := range sample {
            fmt.Println(i, r, string(r))
            if r == 'l' {
                continue outer
            }
        }
        fmt.Println()
    }
```

### 13. Сигнатура функции 

Тип функции составляется из ключевого слова func и типов параметров и возвращаемых значений. Эту комбинацию называют сигнатурой функции. Если у двух функций одинаковы количество и тип параметров, то их сигнатуры типов совпадают.

Поскольку функции являются значениями, вы можете объявить переменную функции: var myFuncVariable func(string) int

### 14. Анонимная функция 

``` go
func main() { 
	f := func(j int) { 
		fmt.Println("printing", j, "from inside of an anonymous function") 
	} 
	for i := 0; i < 5; i++ { 
		f(i) 
	} 
}
```

### 15. Замыкания 

Функции, объявляемые внутри других функций, представляют собой особую разновидность функций, называемую замыканиями. В теории вычислительных машин под замыканием понимается функция, которая объявлена внутри другой функции и может использовать и изменять переменные, объявленные во внешней функции.

``` go
func main() { 
	a := 20 
	f := func() {
		fmt.Println(a) 
		a = 30 
	} 
	f() 
	fmt.Println(a) 
}
```

### 16. Передача функций в качестве параметров 

``` go
// сортировка по фамилии 
sort.Slice(people, func(i int, j int) bool { 
	return people[i].LastName < people[j].LastName 
})
fmt.Println(people)
```

### 17. defer и освобождение 

``` go
func DoSomeInserts(ctx context.Context, db *sql.DB, value1, value2 string) (err error) { 
	tx, err := db.BeginTx(ctx, nil) 
	if err != nil { 
		return err 
	} 
	defer func() { 
		if err == nil { 
			err = tx.Commit() 
		} 
		if err != nil { 
			tx.Rollback() 
		} 
	}() 
	_, err = tx.ExecContext(ctx, "INSERT INTO FOO (val) values $1", value1) 
	if err != nil { 
	return err 
	} // здесь можно выполнить еще ряд операций вставки, используя tx return nil }
```

Чтобы обеспечить гарантированный запуск кода для освобождения ресурсов, следует записать ключевое слово defer перед вызовом функции или метода. Если обычно вызов функции производится немедленно, то при использовании ключевого слова defer вызов откладывается до момента выхода из содержащей его функции.

В одной функции Go можно использовать оператор defer с несколькими функциями. Они выполняются по принципу LIFO: «Последним вошел — первым вышел», то есть оператор defer, указанный последним, выполняется первым. 

Код внутри функций с оператором defer выполняется после выполнения оператора возврата.

В Go широко используется следующий паттерн: функция, которая выделяет некоторый ресурс, также возвращает замыкание, которое высвобождает этот ресурс.

``` go
func getFile(name string) (*os.File, func(), error) { 
	file, err := os.Open(name) 
	if err != nil { 
		return nil, nil, err 
	} 
	return file, func() { 
		file.Close()
	}, nil 
}

f, closer, err := getFile(os.Args[1]) 
if err != nil { 
	log.Fatal(err) 
} 
defer closer()
```

Поскольку в Go неиспользуемые переменные недопустимы, возврат функции closer из другой функции означает, что программа успешно скомпилируется лишь в том случае, если будет вызвана эта функция. Это является еще одним доводом в пользу применения оператора defer

### 18. Go — язык с передачей параметров по значению

При передаче переменной функции в качестве параметра Go всегда создает копию значения переменной. 

В случае среза дело обстоит немного сложнее: вы можете модифицировать любой элемент среза, но не можете увеличить его длину. Так ведут себя те отображения и срезы, которые передаются в функцию напрямую, а также в качестве полей структуры. Это объясняется тем, что и отображения, и срезы реализуются с помощью указателей.

Если потребуется передать функции что-то способное изменяться, необходимо передавать указатель

### 19. Указатели 

Указатель — это просто переменная, содержащая адрес ячейки памяти, в которой размещено значение

``` go
var x int32 = 10 
var y bool = true
```

![[Pasted image 20260103102540.png]]

Каждая переменная хранится в одной или нескольких последовательных ячейках памяти с определенными адресами.

Указатель — это просто переменная, содержащая адрес местоположения другой переменной.

``` go
var x int32 = 10
var y bool = true 
pointerX := &x 
pointerY := &y 
var pointerZ *string
```

![[Pasted image 20260103102747.png]]

В этом случае указатель pointerX, ссылающийся на переменную x, расположен в ячейке с адресом 6 и содержит значение 1 — адрес переменной x.

В примере используются 4-байтные указатели, но многие современные компьютеры работают с 8-байтными. Указатель хранит число — адрес в памяти, где находятся данные.

Символом & обозначается оператор взятия адреса. Он ставится перед типом значения и возвращает адрес ячейки памяти, в которой находится значение.

Символом * обозначается оператор разыменования. Он ставится перед переменной типа указателя и возвращает значение, на которое она указывает, то есть производит так называемое разыменование.

``` go
x := 10 
pointerToX := &x 
*pointerToX := 5
fmt.Println(pointerToX) // выведет адрес в памяти \\
fmt.Println(*pointerToX) // выведет 10 
z := 5 + *pointerToX 
fmt.Println(z) // выведет 15
```

### 20. Адрес литерала простых типов

В структурах экземпляр указателя следует создавать с помощью оператора & перед литералом структуры. Оператор & нельзя использовать перед литералами простых типов (числами, булевыми значениями и строками) или константами, потому что они не имеют адреса в памяти и существуют только во время компиляции. В случае, когда необходимо получить указатель на значение простого типа, следует объявить переменную и создать ссылающийся на нее указатель.

Вспомогательная функция, которая будет принимать булево значение, число или строку и возвращать указатель на это значение

``` go
func makePointer[T any](t T) *T {
	return &t 
}
```

### 21. Передача и изменение указателя в функции

``` go
func failedUpdate(px *int) { 
	x2 := 20 
	px = &x2 
} 

func update(px *int) { 
	*px = 20
} 

func main() { 
	x := 10 failedUpdate(&x) 
	fmt.Println(x) // выведет 10 update(&x) 
	fmt.Println(x) // выведет 20 
}
```

В этом примере функция main начинается с объявления переменной x со значением 10. Когда вызывается функция failedUpdate, адрес переменной x копируется в параметр px. Далее в функции failedUpdate объявляется переменная x2 со значением 20. Внутри функции failedUpdate переменной px присваивается адрес переменной x2. После возврата в функцию main значение переменной x остается неизменным. При вызове функции update адрес переменной x точно так же копируется в параметр px. Однако на этот раз изменяется значение той переменной, на которую указывает переменная px внутри функции update, то есть переменной x, определенной внутри функции main. Соответственно, после возврата в функцию main значение переменной x изменяется.

### 21. Различие между нулевым значением и отсутствием значения

1. **Для полей структуры, где нужно различать "ноль" и "не задано"** (особенно при работе с JSON/БД) — **используйте указатели**.

2. **Для возврата значений из функций**, где возможен случай "не найдено" — **предпочитайте идиому (value, bool)** или возвращайте ошибку, если это более уместно. Избегайте возврата `nil` для простых случаев.

3. **Если значение никогда не должно отсутствовать** и `0` (или `""`, `false`) — валидное значение для логики программы — **используйте обычный значимый тип**.

4. **Если вы не работаете с внешними системами** (JSON, gRPC, БД, где `null` возможен) — **старайтесь обходиться без указателей** для обозначения отсутствия. Это упрощает код и предотвращает случайные паники при разыменовании `nil`.

### 22. Передача срезов в качестве параметров 

Будучи единственной пригодной для использования линейной структурой данных, в Go-программах срезы часто передаются функциям. При этом по умолчанию предполагается, что срез не должен изменяться функцией. Если функция меняет содержимое среза, это должно быть явно указано в ее документации

![[Pasted image 20260103162031.png]]

### 23. Использование срезов в качестве буферов 

Несмотря на то что Go является языком со сборкой мусора, идиоматический подход к написанию Go-кода подразумевает исключение ненужного распределения памяти. Вместо того чтобы выделять новую память при выполнении каждой операции чтения из источника данных, необходимо один раз создать срез байтов и использовать его в качестве буфера для чтения из источника данных:

``` go 
file, err := os.Open(fileName) 
if err != nil { 
	return err 
} 
defer file.Close() 
data := make([]byte, 100) 
for { 
	count, err := file.Read(data) 
	process(data[:count]) 
	if err != nil { 
		if errors.Is(err, io.EOF) { 
			return nil 
		} 
		return err 
	} 
}
```

### 24. Сборка мусора. Стек и куча

Под мусором в программировании понимаются данные, на которые больше не указывает ни один указатель. Когда не остается указателей, указывающих на определенные данные, занимаемую ими область памяти можно освободить для повторного применения. Если этого не делать, объем используемой программой памяти будет возрастать до тех пор, пока не будет исчерпана вся доступная на компьютере оперативная память. Задача сборщика мусора сводится к тому, чтобы выявлять неиспользуемые области памяти и освобождать их для повторного применения.

Сборщик мусора освобождает память не сразу, как только исчезает последняя ссылка на нее, иначе это серьезно влияло бы на производительность. Вместо этого среда выполнения позволяет программе накопить немного мусора. Куча почти всегда содержит как используемые, так и неиспользуемые области памяти.

Стек представляет собой непрерывный блок памяти, который совместно используется всеми вызовами функций в потоке выполнения. Выделение памяти в стеке — быстрый и простой процесс. Указатель стека указывает на то место, где память выделялась в последний раз, и дополнительная память добавляется путем смещения указателя стека. В момент вызова функции для ее данных создается новый кадр стека. В стеке сохраняются локальные переменные и передаваемые функции параметры. При этом каждая новая переменная смещает указатель стека на длину, равную своему значению. Когда функция завершает работу, возвращаемые ею значения копируются обратно в вызывающую функцию с помощью стека и указатель стека возвращается в начало кадра стека для закончившей работу функции, высвобождая ту часть памяти в стеке, которая была занята локальными переменными и параметрами этой функции.

Ситуация немного усложняется, когда дело касается данных, на которые указывает указатель. Для размещения таких данных в стеке должны выполняться несколько условий. Это должна быть локальная переменная с точно определенным размером данных, содержащихся в ней на этапе компиляции. Указатель при этом не может быть возвращен из функции. Если указатель передается в функцию, то компилятор по-прежнему должен иметь возможность проверить соблюдение этих условий. Когда размер данных не определен, вы не можете выделить для них пространство простым смещением указателя стека. Если указатель возвращается из функции, то данные, на которые он указывает, уже не будут корректными после выхода из функции. Когда компилятор определяет, что данные, на которые указывает указатель, невозможно разместить в стеке, мы говорим, что данные покидают стек и сохраняются в куче.

Размещенные в куче данные остаются корректными до тех пор, пока их можно проследить до размещенной в стеке переменной ссылочного типа. Когда уже не остается указателей, указывающих на эти данные (или на данные, указывающие на эти данные), эти данные становятся мусором, который должен быть удален сборщиком мусора.

### 25. А что плохого в том, чтобы размещать данные в куче?

Первая проблема состоит в том, что для сборки мусора требуется время. Контроль за тем, какие области памяти в куче еще свободны и какие из используемых блоков памяти еще обладают корректными указателями, — далеко не простая задача. Чем больше времени тратится на ее решение, тем меньше его остается на обработку, для выполнения которой была написана ваша программа. Множество созданных к настоящему времени алгоритмов сборки мусора можно грубо

Если Go-программа создает много мусора, сборщик мусора не сможет выявить его весь за один цикл, что замедлит работу сборщика и повысит расход памяти.

Вторая проблема обусловлена особенностями аппаратного обеспечения компьютеров. Хотя оперативная память и позволяет осуществлять произвольный доступ, она обеспечивает более высокую скорость при последовательном чтении данных. Срез структур в Go обеспечивает последовательное размещение данных в памяти, что ускоряет их чтение и обработку. Но когда мы имеем дело со срезом указателей на структуры (или со срезом структур, поля которых являются указателями), данные разбросаны по всей оперативной памяти, что замедляет их чтение и обработку

Теперь понятно, почему в Go рекомендуется применять указатели как можно реже. Тем самым снижается нагрузка на сборщик мусора за счет того, что максимально возможная часть данных сохраняется в стеке. При использовании срезов структур или простых типов данные располагаются в памяти последовательно, что обеспечивает высокую скорость доступа. А когда сборщик мусора все же принимается за свою работу, он стремится затратить на нее как можно меньше времени, вместо того чтобы пытаться собрать как можно больше мусора. Ключ к повышению эффективности этого подхода в создании меньшего количества мусора. Хотя кто-то может посчитать такую оптимизацию операций выделения памяти преждевременной, следует отметить, что для обеспечения максимальной эффективности в Go достаточно просто придерживаться идиоматического подхода.

### 26. Пример переноса объекта в кучу

``` go
type Person struct {
	FirstName string
	LastName  string
	Age       int
}

func MakePerson(firstName, lastName string, age int) Person {
	return Person{
		FirstName: firstName,
		LastName:  lastName,
		Age:       age,
	}
}

func MakePersonPointer(firstName, lastName string, age int) *Person {
	return &Person{
		FirstName: firstName,
		LastName:  lastName,
		Age:       age,
	}
}

func main() {
    p := MakePerson("Fred", "Williamson", 25)
    fmt.Println(p)
    p2 := MakePersonPointer("Wilma", "Fredson", 32)
    fmt.Println(p2)
}
```
Компиляция кода с параметром -gcflags="-m" показывает, когда значения уходят в кучу (она также показывает, когда функции встраиваются, что является оптимизацией компилятора, не рассматриваемой в этой книге):

``` txt
$ go build -gcflags="-m"
# github.com/learning-go-book-2e/ch06/exercise_solutions/ex1
./main.go:11:6: can inline MakePerson
./main.go:19:6: can inline MakePersonPointer
./main.go:28:17: inlining call to MakePerson
./main.go:29:13: inlining call to fmt.Println
./main.go:30:25: inlining call to MakePersonPointer
./main.go:31:13: inlining call to fmt.Println
./main.go:11:17: leaking param: firstName to result ~r0 level=0
./main.go:11:28: leaking param: lastName to result ~r0 level=0
./main.go:19:24: leaking param: firstName
./main.go:19:35: leaking param: lastName
./main.go:20:9: &Person{...} escapes to heap
./main.go:29:13: ... argument does not escape
./main.go:29:14: p escapes to heap
./main.go:30:25: &Person{...} escapes to heap
./main.go:31:13: ... argument does not escape
```

Значение &Person{}, возвращаемое из MakePersonPointer, сохраняется в куче. Каждый раз, когда из функции возвращается указатель, он возвращается в стек, но значение, на которое он указывает, должно храниться в куче.

Удивительно, но в нем также говорится, что p передается в кучу. Причина этого в том, что он передается в fmt.Println. Это потому, что параметр для fmt.Println любой. Текущий компилятор Go перемещает в кучу любое значение, передаваемое функции через параметр, относящийся к типу интерфейса

### 27. Методы тоже являются функциями 

Мы также можем присвоить метод переменной и передать его в качестве параметра типа func(int)int. Это называют значением метода:

``` go
f1 := myAdder.AddTo // myAdder - экземпляр типа Adder
fmt.Println(f1(10)) // выведет 20
```

Значение метода имеет определенное сходство с замыканием, поскольку может обращаться к значениям полей того экземпляра, на основе которого было создано.

Можно создать функцию и непосредственно на основе типа. Это называют выражением метода:

``` go
f2 := Adder.AddTo // Adder - структура
fmt.Println(f2(myAdder, 15)) // выведет 25
```

### 28. iota 

Йота иногда используется для создания перечислений

``` go
const ( 
	Field1 = 0 
	Field2 = 1 + iota 
	Field3 = 20 
	Field4 
	Field5 = iota 
) 
func main() { 
	fmt.Println(Field1, Field2, Field3, Field4, Field5) // 0 2 20 20 4
}
```

 Классическое использование `iota` для создания битовых масок (bit flags) в Go

``` go
const (
    Field1 BitField = 1 << iota // iota = 0, 1 << 0 = 1
    Field2                      // iota = 1, 1 << 1 = 2
    Field3                      // iota = 2, 1 << 2 = 4  
    Field4                      // iota = 3, 1 << 3 = 8
)
```

### 29. Наследования и композиция 

### Наследование (Inheritance) - "IS-A" отношение

``` java
// Классический пример
class Animal {
    void eat() { /* ... */ }
}

class Dog extends Animal {  // Dog IS-A Animal
    void bark() { /* ... */ }
}
```
### Композиция (Composition) - "HAS-A" отношение

```go
type Animal struct {
    // поведение через интерфейсы
}

type Dog struct {
    animal *Animal  // Dog HAS-A Animal
    breed  string
}
```

``` go
type Employee struct {
	Name string 
	ID string 
}
 
func (e Employee) Description() string { 
	return fmt.Sprintf("%s (%s)", e.Name, e.ID) 
}
 
type Manager struct { 
	Employee 
	Reports []Employee 
} 

func (m Manager) FindNewEmployees() []Employee { 
	// выполнение бизнес-логики 
}
```

Обратите внимание на то, что структура Manager содержит поле типа Employee, но ему не присваивается какое-либо имя. Это делает поле Employee **встроенным**. Любые поля или методы, объявленные во встроенном поле, **становятся частью** содержащей его структуры, то есть становятся встроенными методами вмещающей структуры и могут быть вызваны непосредственно для нее. Это позволяет нам написать следующий код:

``` go
m := Manager{ 
	Employee: Employee{ 
		Name: "Bob Bobson",
		ID: "12345", 
	}, 
	Reports: []Employee{}, 
} 

fmt.Println(m.ID) // выведет 12345 
fmt.Println(m.Description()) // выведет "Bob Bobson" (12345)
```