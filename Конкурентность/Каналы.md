
![[Pasted image 20260119175142.png]]

### Микропаттерн генератор 

``` go
func writer() <-chan int {
	ch := make(chan int)
	wg := &async.WaitGroup{}
	
	wg.Add(2)
	go func() {
		defer wg.Done()
		
		for i := range 5 {
			ch <- i + 1
		}
	}()
	
	go func() {
		defer wg.Done()
		
			for i := range 5 {
			ch <- i + 11
		}
	}()
	
	go func() {
		wg.Wait() // Т.к. это паттерн генератор, мы не должны блокировать основной поток
		close(ch)
	}
	
	return ch
} 
```

Пример 

``` go
package main

import (
    "fmt"
    "time"
)

func reader(inputCh <-chan int) {
    go func() {
        for v := range inputCh {
            fmt.Println(v)
        }
    }()
}

func doubler(inputCh <-chan int) <-chan int {
    ch := make(chan int)
    go func() {
        for v := range inputCh {
            time.Sleep(500 * time.Millisecond)
            ch <- 2 * v
        }
        close(ch)
    }() 
    return ch
}

func writer() <-chan int {
    ch := make(chan int)
    go func() {
        for i := range 10 {
            ch <- i + 1
        }
        close(ch)
    }()
    return ch
}

func main() {
    reader(doubler(writer()))
    time.Sleep(10 * time.Second)
}
```

Пример обертки, который останавливает функцию, если она работает дольше 3 секунд, с использованием Select и Context

``` go
func randomTimeWork() {
    time.Sleep(time.Duration(rand.Intn(100)) * time.Second)
}

func predictableTimeWork() {
    ch := make(chan struct{})
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    go func() {
        randomTimeWork()
        close(ch)
    }()

    select {
    case <-ch:
        fmt.Println("func is done")
        return
    case <-ctx.Done():
        fmt.Println("3 sec is over")
        return
    }
}

func main() {
    predictableTimeWork()
}
```

Можно использовать time.After(3 * time.Second) или timer.C (тут без секунд)

![[Pasted image 20260120000454.png]]