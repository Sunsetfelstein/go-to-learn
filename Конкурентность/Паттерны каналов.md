### FAN-IN

![[Pasted image 20260120225553.png]]

``` go
func MergeChannels [T any] (channels ...<-chan T) <-chan T {
	var wg sync.WaitGroup 
	wg.Add(len(channels))
	outputCh= make(chan T)
	
	for, channel := range channels { 
		go func() {
			defer wg.Done()
			for value := range channel { 
				outputCh<value
			}
		}()
	}

	go func() {
		wg.Wait() 
		close(outputCh)
	}()
	
	return outputCh
}
```

### FAN-OUT

![[Pasted image 20260120225623.png]]

``` go
func SplitChannel[T any](inputCh <-chan T, n int) []<-chan T {
	outputChs := make([]chan T, n)
	for i := 0; i < n; i++ {
		outputChs[i] = make(chan T)
	}

	go func() {
		idx := 0
		for value := range inputCh {
			outputChs[idx] <- value // can be non-blocking
			idx = (idx + 1) % n
		}

		for _, ch := range outputChs {
			close(ch)
		}
	}()

	// cannot cast []chan T to []<-chan T
	resultChs := make([]<-chan T, n)
	for i := 0; i < n; i++ {
		resultChs[i] = outputChs[i]
	}

	return resultChs
}
```

### TEE

По семантике похож на FAN-OUT, но на выходе запись идет во все каналы

![[Pasted image 20260120230726.png]]

``` go 
func Tee[T any](inputCh <-chan T, n int) []<-chan T {
	outputChs := make([]chan T, n)
	for i := 0; i < n; i++ {
		outputChs[i] = make(chan T)
	}

	go func() {
		for value := range inputCh {
			for i := 0; i < n; i++ {
				outputChs[i] <- value // can be non-blocking
			}
		}

		for _, channel := range outputChs {
			close(channel)
		}
	}()

	// cannot cast []chan T to []<-chan T
	resultChs := make([]<-chan T, n)
	for i := 0; i < n; i++ {
		resultChs[i] = outputChs[i]
	}

	return resultChs
}

```

### Transformer (Decorator)

![[Pasted image 20260120231221.png]]

``` go
func Transform[T any](inputCh <-chan T, action func(T) T) <-chan T {
	outputCh := make(chan T)

	go func() {
		defer close(outputCh)
		for number := range inputCh {
			outputCh <- action(number)
		}
	}()

	return outputCh
}

```

### Filter 

![[Pasted image 20260120231248.png]]

``` go
func Filter[T any](inputCh <-chan T, predicate func(T) bool) <-chan T {
    outputCh := make(chan T)

    go func() {
        defer close(outputCh)
        
        for value := range inputCh {
            if predicate(value) {
                outputCh <- value
            }
        }
    }()

    return outputCh
}
```

### Pipeline

![[Pasted image 20260120231528.png]]

``` go
func generate[T any](values ...T) <-chan T {
    outputCh := make(chan T)
    
    go func() {
        defer close(outputCh)
        for _, value := range values {
            outputCh <- value
        }
    }()
    
    return outputCh
}

func process[T any](inputCh <-chan T, action func(T) T) <-chan T {
    outputCh := make(chan T)
    
    go func() {
        defer close(outputCh)
        for value := range inputCh {
            outputCh <- action(value)
        }
    }()
    
    return outputCh
}

func main() {
    values := []int{1, 2, 3, 4, 5}
    
    mul := func(value int) int {
        return value * value
    }
    
    for value := range process(generate(values...), mul) {
        fmt.Println(value)
    }
}
```

![[Pasted image 20260120232123.png]]

``` go
func parse(inputCh <-chan string) <-chan string {
    outputCh := make(chan string)
    go func() {
        defer close(outputCh)
        for data := range inputCh {
            outputCh <- fmt.Sprintf("parsed - %s", data)
        }
    }()
    return outputCh
}

func send(inputCh <-chan string, n int) <-chan string {
    var wg sync.WaitGroup
    wg.Add(n)
    outputCh := make(chan string)

    for i := 0; i < n; i++ {
        go func() {
            defer wg.Done()
            for data := range inputCh {
                outputCh <- fmt.Sprintf("sent - %s", data)
            }
        }()
    }

    go func() {
        wg.Wait()
        close(outputCh)
    }()

    return outputCh
}

func main() {
    channel := make(chan string)

    // Producer: отправляет 5 значений "value" + закрывает канал
    go func() {
        defer close(channel)
        for i := 0; i < 5; i++ {
            channel <- "value"
        }
    }()

    // Цепочка: channel → parse → send(2 worker'а) → for range
    for value := range send(parse(channel), 2) {
        fmt.Println(value)
    }
}
```

![[Pasted image 20260120232648.png]]

``` go
func split[T any](inputCh <-chan T, n int) []<-chan T {
	outputChs := make([]chan T, n)
	for i := 0; i < n; i++ {
		outputChs[i] = make(chan T)
	}

	go func() {
		idx := 0
		for value := range inputCh {
			outputChs[idx] <- value // can be non-blocking
			idx = (idx + 1) % n
		}

		for _, ch := range outputChs {
			close(ch)
		}
	}()

	// cannot cast []chan T to []<-chan T
	resultChs := make([]<-chan T, n)
	for i := 0; i < n; i++ {
		resultChs[i] = outputChs[i]
	}

	return resultChs
}

func parse(inputCh <-chan string) <-chan string {
    outputCh := make(chan string)
    go func() {
        defer close(outputCh)
        for data := range inputCh {
            outputCh <- fmt.Sprintf("parsed - %s", data)
        }
    }()
    return outputCh
}

func send(inputCh <-chan string, n int) <-chan string {
    var wg sync.WaitGroup
    wg.Add(n)
    outputCh := make(chan string)
    splittedChs := split(inputCh, n)

    for i := 0; i < n; i++ {
        go func(idx int) {
            defer wg.Done()
            for data := range splittedChs[idx] {
                outputCh <- fmt.Sprintf("sent - %s", data)
            }
        }(i)
    }

    go func() {
        wg.Wait()
        close(outputCh)
    }()

    return outputCh
}

func main() {
    channel := make(chan string)

    // Producer: отправляет 5 значений "value" + закрывает канал
    go func() {
        defer close(channel)
        for i := 0; i < 5; i++ {
            channel <- "value"
        }
    }()

    // Цепочка: channel → parse → send(2 worker'а) → for range
    for value := range send(parse(channel), 2) {
        fmt.Println(value)
    }
}
```

### Done channel (Graceful shutdown)

Как корректно завершить долгоживущую горутину по внешнему сигналу

``` go
func process(closeCh <-chan struct{}) <-chan struct{} {
    closeDone := make(chan struct{})

    go func() {
        defer close(closeDone)

        for {
            select {
            case <-closeCh:
                // сюда попадаем, когда кто-то закрыл closeCh
                return   // выходим из цикла → defer закроет closeDone
            default:
                // обычная работа (в реальном коде здесь будет полезная логика)
                // fmt.Println("processing...")
                // time.Sleep(100 * time.Millisecond)
                // или чтение из других каналов, обработка запросов и т.д.
            }
        }
    }()

    return closeDone
}

func main() {
    closeCh := make(chan struct{})
    closeDone := process(closeCh)

    // ... здесь может быть долгое время работы программы ...

    close(closeCh)                // ← посылаем сигнал "заканчиваем"
    <-closeDone                   // ← ждём, пока worker действительно завершится
    fmt.Println("terminated")
}
```

### Done channel со структурой 

``` go
type Worker struct {
    closeCh    chan struct{}   // канал-сигнал "пора завершаться"
    closeDoneCh chan struct{}  // канал, который закроется, когда worker действительно завершил работу
}

func NewWorker() *Worker {
    w := &Worker{
        closeCh:     make(chan struct{}),
        closeDoneCh: make(chan struct{}),
    }

    go func() {
        ticker := time.NewTicker(time.Second)
        defer ticker.Stop()

        for {
            select {
            case <-w.closeCh:
                close(w.closeDoneCh)
                return

            default:
                // Здесь должна быть полезная работа
                // (в примере она отсутствует — worker просто "спит" 1 секунду)
            }

            // Вариант 2: более чистый и частый паттерн
            select {
            case <-w.closeCh:
                close(w.closeDoneCh)
                return
            case <-ticker.C:
                // Здесь полезная работа, которая выполняется раз в секунду
                // fmt.Println("working...")
            }
        }
    }()

    return w
}

func (w *Worker) Shutdown() {
    close(w.closeCh)     // посылаем сигнал "завершайся"
    <-w.closeDoneCh      // ждём подтверждения завершения
}

func main() {
    worker := NewWorker()
    time.Sleep(5 * time.Second)
    worker.Shutdown()
    // после этой строки worker гарантированно завершён
}

```

### OrDone (orDone / takeUntil / orDoneChan)

Паттерн отмены/раннего завершения** при чтении из канала, когда у нас есть два источника событий:

- основной канал с данными (inputCh chan T)
- канал отмены/завершения (doneCh chan struct{})

Она возвращает **новый канал**, который выдаёт значения из inputCh, пока не закроется inputCh **или** не придёт сигнал в doneCh.

``` go
func OrDone[T any](inputCh chan T, doneCh chan struct{}) <-chan T {
    outputCh := make(chan T)

    go func() {
        defer close(outputCh)

        for {
            select {
            case <-doneCh:
                return
            default:
            }

            select {
            case value, opened := <-inputCh:
                if !opened {
                    return
                }
                outputCh <- value
            case <-doneCh:
                return
            }
        }
    }()

    return outputCh
}

func main() {
    channel := make(chan string)

    go func() {
        for {
            channel <- "test"
            time.Sleep(200 * time.Millisecond)
        }
    }()

    done := make(chan struct{})

    go func() {
        time.Sleep(time.Second)
        close(done)
    }()

    for value := range OrDone(channel, done) {
        fmt.Println(value)
    }
}
```