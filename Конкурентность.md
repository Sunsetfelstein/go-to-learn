Под конкурентностью в теории вычислительных машин понимается разбиение одного процесса на несколько независимых составляющих и определение для них безопасного способа совместного использования данных.

Конкурентность в Go основана на теории взаимодействующих последовательных процессов (Communicating Sequential Processes, CSP)

Дополнительное использование конкурентности не всегда ведет к повышению производительности и часто делает код менее понятным. Важно понимать, что конкурентность — это не параллелизм. Конкурентность — это инструмент, позволяющий лучше структурировать решаемую задачу.

Будет или нет конкурентный код выполняться параллельно (одновременно), зависит от используемого аппаратного обеспечения и от того, позволяет ли это алгоритм.

Если не вдаваться в подробности, то процесс выполнения любой программы можно разделить на три этапа: получение данных, их преобразование и вывод результата. Ответ на вопрос, следует или нет использовать в программе конкурентность, зависит от того, как движутся данные в программе по мере выполнения этих этапов.

Применяйте конкурентность, когда требуется объединить результаты нескольких операций, которые могут выполняться независимо друг от друга.

Важно также отметить, что конкурентность не стоит использовать в тех случаях, когда выполнение процессов не занимает много времени. Помните о том, что конкурентность несет за собой определенные издержки.

### Горутины

Горутины — ключевая концепция модели конкурентности языка Go.

Процесс — это экземпляр программы, выполняемой операционной системой компьютера. Операционная система связывает с процессом такие ресурсы, как память, и следит за тем, чтобы другие процессы не могли их использовать. Процесс состоит из одного или нескольких потоков.

Поток — это единица выполнения, на работу которой операционная система дает некоторое время. Потоки одного процесса совместно используют его ресурсы. Центральный процессор может выполнять инструкции из одного или нескольких потоков одновременно в зависимости от количества имеющихся у него ядер. Одной из задач операционной системы является планирование выполнения потоков процессором таким образом, чтобы были выполнены каждый процесс и каждый его поток.

Горутины — это легковесные потоки, которыми распоряжается среда выполнения языка Go.

При запуске Go-программы среда выполнения языка Go создает для нее несколько потоков и запускает одну горутину. Все создаваемые программой горутины, включая самую первую, автоматически закрепляются за этими потоками планировщиком среды выполнения языка Go, подобно тому как операционная система планирует выполнение потоков центральным процессором.

* Создание горутины занимает меньше времени, чем создание потока, поскольку при этом не создается системный ресурс.
* Исходный размер стека горутин меньше размера стека потоков иможет увеличиваться по мере необходимости. Это делает горутины более эффективными в плане использования памяти.
* Переключение между горутинами занимает меньше времени, чем переключение между потоками, поскольку осуществляется полностью внутри процесса, без обращений к сравнительно медленным системным вызовам.
* Являясь составной частью процесса, планировщик может оптимизировать свои решения. Взаимодействуя с механизмом опроса сетевых соединений, планировщик выявляет горутины, заблокированные в операции ввода-вывода, и не планирует их на выполнение. Он также взаимодействует со сборщиком мусора и следит за тем, чтобы работа была равномерно распределена между потоками операционной системы, выделенными для вашего Go-процесса.

Эти преимущества позволяют Go-программам создавать сотни, тысячи и даже десятки тысяч одновременных горутин

Горутина запускается размещением ключевого слова go перед вызовом функции. Такой функции, как и любой другой, можно передать параметры для инициализации ее состояния, но ее возвращаемые значения будут игнорироваться.

В то же время горутины принято запускать с помощью замыкания, обертывающего бизнес-логику. При этом замыкание берет на себя выполнение всей работы по обеспечению конкурентности.

### Каналы

Горутины общаются друг с другом посредством каналов. Подобно срезам и отображениям, каналы представляют собой встроенный тип, экземпляры которого создаются с помощью функции make: 

```go 
ch := make(chan int) 
```

Как и отображения, каналы представляют собой ссылочный тип. Когда вы передаете канал функции, ей в действительности передается указатель на канал. И так же, как для отображений и срезов, нулевым значением для каналов является значение nil.

### Чтение, запись и буферизация

Взаимодействия с каналом выполняются с помощью оператора <-. Для чтения из канала нужно поставить оператор <- слева от переменной канала, а для записи в канал — справа:

``` go
a := <-ch // читает значение из канала ch и присваивает его переменной a 
ch <- b // записывает значение переменной b в канал ch
```

Значение, записанное в канал, можно прочитать только один раз. Если данные из канала читают несколько горутин, то записанное в него значение прочитает только одна из них

Горутины редко читают данные из одного и того же канала и записывают в один и тот же канал. Если значение канала присваивается переменной или полю либо передается в качестве параметра функции, поставьте стрелку перед ключевым словом chan (например, ch <-chan int), чтобы указать, что горутина только читает из канала. 

Чтобы указать, что горутина только записывает в канал, поставьте стрелку после ключевого слова chan (например, ch chan<- int). Это поможет компилятору языка Go гарантировать, что функция будет производить только чтение из канала или только запись в него.

По умолчанию каналы являются небуферизованными. После каждой операции записи в открытый небуферизованный канал пишущая горутина приостанавливается, пока другая горутина не прочитает данные из этого канала. Точно так же после каждой операции чтения из открытого небуферизованного канала читающая горутина приостанавливается, пока другая горутина не запишет новое значение в него. Это означает, что при использовании небуферизованного канала требуются как минимум две параллельно работающие горутины.

Go позволяет задействовать и буферизованные каналы, которые буферизуют без блокировки некоторое ограниченное количество операций записи. Если буфер заполнится до выполнения каких-либо операций чтения из канала, то следующая операция записи в этот канал приостановит записывающую горутину, пока не будет произведено чтение из канала. Точно так же попытка чтения из канала с пустым буфером приостановит читающую горутину.

``` go
ch := make(chan int, 10)
```

``` go
for v := range ch { 
	fmt.Println(v) 
}
```

После завершения записи в канал его следует закрыть вызовом встроенной функции close:

``` go
close(ch)
```

### Мьютекс 

Это примитив синхронизации, обеспечивающий взаимное исключения исполнения критических участков кода.

Критическая секция - область кода, которая находится между Lock и Unlock. И гарантия мьютекса в том, что в этот участок кода не может попасть больше одной горутины

![[Pasted image 20260118153652.png]]