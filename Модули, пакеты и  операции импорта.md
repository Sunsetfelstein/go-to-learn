
Управление библиотеками в Go основано на трех концепциях, таких как репозитории, модули и пакеты. Что такое репозиторий, знает любой разработчик. Это место в системе управления версиями, где хранится исходный код проекта. Модуль — это комплект исходного кода на Go, который хранится в репозитории и распространяется как единое целое. Каждый модуль включает один или несколько пакетов — каталогов с исходным кодом, что придает модулю определенную структуру.

В Go в качестве идентификатора обычно используется путь к репозиторию, в котором находится модуль.
### go.mod

Команда go mod init ПУТЬ_К_МОДУЛЮ создаст файл go.mod, превращающий текущий каталог в корень модуля. ПУТЬ_К_МОДУЛЮ здесь представляет собой глобально уникальное имя, идентифицирующее модуль. Путь чувствителен к регистру. Во избежание путаницы не используйте в нем буквы верхнего регистра

Дерево каталогов с исходным кодом на языке Go становится модулем в том случае, если в его корневом каталоге имеется корректный файл go.mod.

``` txt
module github.com/learning-go-book-2e/money 
go 1.21 
require ( 
	github.com/learning-go-book-2e/formatter v0.0.0-20220918024742-18...
	github.com/shopspring/decimal v1.3.1
)
require ( 
	github.com/fatih/color v1.13.0 // indirect 
	github.com/mattn/go-colorable v0.1.9 // indirect 
	github.com/mattn/go-isatty v0.0.14 // indirect 
	golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c // indirect )
```

Каждый файл go.mod начинается с объявления модуля, которое включает в себя ключевое слово module и уникальный путь к модулю. Далее в директиве go указывается минимальная совместимая версия языка Go. Весь исходный код в модуле должен быть совместим с заданной версией. Например, если указать довольно старую версию 1.12, то компилятор не позволит использовать символы подчеркивания в числовых литералах, поскольку эта возможность была добавлена в Go 1.13.

### Директивы toolchain и переменной окружения GOTOOLCHAIN.

Им можно присвоить следующие значения: 
* auto — загружает более новые версии Go (это поведение по умолчанию в Go 1.21 и более поздних версиях); 
* local — восстанавливает поведение версий, предшествовавших Go 1.21; 
* в случае задания конкретной версии Go, например go1.20.4, она будет загружена и использована для сборки программы.

### Директива require

В этих директивах перечисляются модули, от которых зависит данный модуль, и указывается минимальная версия для каждого из них. Первая секция require перечисляет прямые зависимости модуля, вторая — зависимости зависимостей. Каждая строка в этой секции заканчивается комментарием // indirect. Функционально модули с такими комментариями и без них ничем не различаются, они служат лишь как документация для тех, кто будет просматривать файл go.mod.


### Компиляция пакетов
### Операции импорта и экспорта

В Go оператор import позволяет получить доступ к константам, переменным, функциям и типам, экспортируемым другим пакетом.

В Go для этого нет специального ключевого слова, а доступность идентификаторов за пределами пакета, в котором они объявляются, определяется по регистру символов. Если идентификатор начинается с буквы верхнего регистра, он экспортируемый, а если с буквы нижнего регистра или с символа подчеркивания, то будет доступен только внутри пакета, в котором объявлен

Все, что вы экспортируете, — это часть API вашего пакета. Прежде чем экспортировать идентификатор, убедитесь в том, что хотите предоставить клиентам доступ к нему. Документируйте все экспортируемые идентификаторы и следите за тем, чтобы они оставались обратно совместимыми при внесении изменений, если только вы не планируете намеренно внести значительные изменения в версию модуля

### Создание и использование пакета

``` go
package math 

func Double(a int) int { 
	return a * 2
}
```

Первая строка в этом файле содержит спецификатор пакета, который состоит из ключевого слова package и имени пакета. Первая непустая инезакомментированная строка любого файла исходного кода на языке Go содержит спецификатор пакета.

Каталог do-format содержит файл formatter.go со следующим кодом:

``` go
package format 

import "fmt" 

func Number(num int) string { 
	return fmt.Sprintf("The number is %d", num) 
}
```

Наконец, корневой каталог содержит файл main.go со следующим кодом:

``` go
package main 

import ( 
	"fmt" 
	
	"github.com/learning-go-book-2e/package_example/do-format" 
	"github.com/learning-go-book-2e/package_example/math" 
)

func main() { 
	num := math.Double(2) 
	output := format.Number(num) 
	fmt.Println(output) 
}
```

Имя пакета определяется его спецификатором, а не путем импорта.

Как правило, имя пакета совпадает с именем содержащего его каталога, поскольку в противном случае будет трудно выяснить, как называется пакет. Однако бывают ситуации, когда необходимо использовать имя пакета, отличающееся от имени каталога.

Имена пакетов должны быть описательными. Вместо такого имени, как util, пакету лучше дать имя, описывающее предоставляемую им функциональность.

Функция или метод что-то делает, поэтому ее/его имя должно быть глаголом, отражающим действие. Имя пакета должно быть существительным, описывающим что-то, что создается или изменяется функциями в пакете. 

Следуя этим правилам, можно создать пакет с именем names и двумя функциями, Extract и Format. Тогда первая будет называться names.Extract, а вторая — names.Format. 

Следует также избегать повторения имени пакета в именах функций и типов, определенных в этом пакете. Не стоит давать функции имя ExtractNames, если она определяется в пакете extract. Исключение из этого правила — случай, когда имя идентификатора совпадает с именем пакета. Например, в пакете sort стандартной библиотеки есть функция Sort, а в пакете context — интерфейс Context.

### Переопределение имени пакета

Если имена пакетов повторяются, вы можете переопределить их имена

``` go
import ( 
	crand "crypto/rand" 
	"encoding/binary" 
	"fmt" 
	"math/rand" 
)
```

### Комментарии пакета и Go Doc

У языка Go имеется формат для написания комментариев, автоматически преобразуемых в документацию. Он называется Go Doc и отличается исключительной простотой.

* Комментарий следует размещать непосредственно перед документируемым элементом, не оставляя пустых строк между комментарием и объявлением этого элемента. 
* В начале комментария должны стоять два символа косой черты (//), а за ними — имя элемента. Допускается также использовать блочные комментарии, заключенные в пары символов /* и */, но предпочтительнее комментарии, начинающиеся с двух символов косой черты.
* Комментарий с описанием функции, типа, константы, переменной или метода должен начинаться с описываемого идентификатора.
* Комментарии можно разбивать на абзацы с помощью пустого комментария.

Общедоступную документацию можно просматривать онлайн в формате HTML. Если вы хотите, чтобы ваши документы выглядели немного презентабельнее, используйте следующие приемы форматирования.

* Если хотите включить в комментарий предварительно отформатированное содержимое, например таблицу или исходный код, добавляйте дополнительные пробелы после начала комментария //, чтобы оформить отступы. 
* Чтобы оформить заголовок в комментарии, после // поставьте # и пробел. В отличие от разметки Markdown, формат Go Doc не позволяет использовать несколько символов # для создания заголовков разных уровней. 
* Чтобы создать ссылку на другой пакет (в текущем модуле или каком-то другом), заключите путь к пакету в квадратные скобки ([ и ]). Чтобы создать ссылку на экспортируемый символ, поместите его имя в квадратные скобки. Если символ находится в другом пакете, используйте префикс с именем пакета — [pkgName.SymbolName]. 
* Если включить в комментарий URL, он будет преобразован в ссылку. 
* Если хотите включить в ссылку на веб-страницу свой текст, то поместите его в квадратные скобки ([ и ]). В конце блока комментария объявите соответствия между вашим текстом и URL в формате // [ТЕКСТ]: URL. 

#### Комментарии уровня пакета 

``` go
// Пакет convert предоставляет различные утилиты с целью облегчить 
// конвертирование денежных сумм из одной валюты в другую 
package convert
```

#### Комментарий к структуре

``` go 
// Money содержит информацию о размере денежной суммы 
// и о том, в какой валюте она исчисляется 
//
// Значение хранится в поле типа [github.com/shopspring/decimal.Decimal] 
type Money struct { 
	Value decimal.Decimal 
	Currency string
}
```

#### Хорошо прокомментированная функция

``` go
// Convert конвертирует денежные суммы из одной валюты в другую. 
// 
// Эта функция принимает два параметра: экземпляр структуры Money, 
// содержащий преобразуемую сумму, и строку с названием валюты, в которую 
// производится пересчет. Convert возвращает сумму в указанной валюте 
// или ошибку, если валюта неизвестна или конвертирование в нее 
// не поддерживается. 
// 
// В случае ошибки возвращаемый экземпляр структуры Money 
// устанавливается в нулевое значение. 
// 
// Поддерживаются следующие валюты: 
// USD — доллар США 
// CAD — канадский доллар 
// EUR — евро 
// INR — индийская рупия 
// 
// Более подробные сведения о курсах обмена валют 
// можно найти на [Investopedia]. 
// 
// [Investopedia]: https://www.investopedia.com/terms/e/exchangerate.asp 
func Convert(from Money, to string) (Money, error) { 
	// ... 
}
```

В комплект поставки языка Go входит инструмент командной строки go doc, который позволяет просматривать комментарии Go Doc. Команда go doc ИМЯ_ПАКЕТА выводит комментарии Go Doc из указанного пакета и список имеющихся в нем идентификаторов. С помощью команды go doc ИМЯ_ПАКЕТА.ИМЯ_ИДЕНТИФИКАТОРА можно вывести документацию для определенного идентификатора в пакете. 

Для просмотра получившейся документации в формате HTML перед публикацией модуля в Интернете воспользуйтесь утилитой pkgsite.

``` txt
$ go install golang.org/x/pkgsite/cmd/pkgsite@latest
```

Далее перейдите в корневой каталог вашего модуля и выполните команду: 

``` txt
$ pkgsite
```

Затем откройте в браузере страницу http://localhost:8080, где вы увидите свой проект и его исходный код.

### Пакет internal

В некоторых случаях требуется сделать функцию, тип или константу общими для пакетов модуля, не превращая их при этом в часть вашего API. В Go это можно сделать с помощью пакета со специальным именем internal. Все идентификаторы, экспортируемые пакетом internal и его подпакетами, будут доступны только в пакетах одного с ним уровня и в родительском пакете.

### Циклические зависимости

Cоздатели языка Go ставили себе целью создание быстрого компилятора и простого в понимании синтаксиса. Поэтому Go не допускает наличия циклических зависимостей между пакетами. Это значит, что если пакет A прямо или косвенно импортирует пакет B, то пакет B не может прямо или косвенно импортировать пакет A.

Если два пакета зависят друг от друга, то, возможно, их следует объединить в один пакет.

### Переименование и реорганизация API без потери работоспособности

По мере использования модуля вы можете обнаружить, что его API требует определенных изменений. Возможно, вы захотите переименовать часть экспортируемых идентификаторов или переместить их в другой пакет в пределах того же модуля. Чтобы не нарушать обратную совместимость при внесении этих изменений, не удаляйте исходные идентификаторы, а просто дополните их альтернативными именами. 

Для функции или метода это довольно легко сделать. Нужно просто определить функцию или метод, вызывающие исходную версию. В случае константы объявляется новая константа того же типа и с тем же значением, но с другим именем.

Когда требуется переименовать или переместить экспортируемый тип, следует задействовать псевдоним. Говоря простым языком, псевдоним — это новое имя для типа.

``` go
type Bar = Foo
```

Для создания псевдонима нужно записать ключевое слово type, имя, которое будет служить псевдонимом, знак равенства и имя исходного типа. Псевдоним имеет те же поля и методы, что и исходный тип. Кроме того, псевдоним может быть присвоен переменной исходного типа без преобразования типа.

Важно помнить, что псевдоним — это просто другое имя типа. Если вы хотите добавить новые методы или изменить поля в структуре, для которой имеется псевдоним, то эти изменения следует произвести в исходном типе.

При объявлении псевдонима для типа, определенного в другом пакете, псевдоним нельзя использовать для обращения к неэкспортируемым методам и полям исходного типа

Это ограничение можно обойти, вызывая код в пакете, содержащем исходный тип, производящий манипуляции над неэкспортируемыми полями и методами.

Однако есть два вида экспортируемых идентификаторов, которые не могут иметь альтернативных имен: переменные уровня пакета и поля структур. После выбора имени для экспортируемого поля структуры ему уже нельзя будет присвоить альтернативное имя.

### По возможности не используйте функцию init

При чтении Go-кода обычно вполне понятно, какие методы и функции вызываются и когда именно.

Если вы определите функцию init без входных параметров и возвращаемых значений, она будет выполняться при первом обращении к данному пакету из другого пакета. Поскольку функции init не имеют входных параметров и возвращаемых значений, они могут лишь производить некоторые побочные эффекты путем взаимодействия с функциями и переменными уровня пакета.

В настоящее время функции init используются главным образом для инициализации переменных уровня пакета, которые не могут быть настроены с помощью одной операции присваивания. Как мы знаем, определение изменяемого состояния на уровне пакета — плохая идея, поскольку это усложняет анализ существующих в приложении потоков данных. Это означает, что любые переменные уровня пакета, настраиваемые с помощью функций init, должны быть фактически неизменяемыми

Учитывая тот факт, что функции init вызываются неявно, обязательно задокументируйте их поведение.

### Работа с модулями. Импортирование стороннего кода

Сторонний код импортируется точно так же, как импортируются стандартные библиотеки, такие, как fmt, errors, os, math. В отличие от многих других языков Go компилирует в один двоичный файл весь код приложения, включая собственный и сторонний код.

Так же как и при импорте пакета из собственного проекта, при импорте стороннего пакета нужно указать его расположение в репозитории исходного кода.

``` go
import ( 
	"fmt" 
	"log" 
	"os" 
	
	"github.com/learning-go-book-2e/formatter"
	"github.com/shopspring/decimal"
)
```

После запуска компиляции на экран будет выведено следующее

``` txt
$ go build 
main.go:8:2: no required module provides package 
	github.com/learning-go-book-2e/formatter; to add it: 
		go get github.com/learning-go-book-2e/formatter 
main.go:9:2: no required module provides package 
	github.com/shopspring/decimal; to add it: 
		go get github.com/shopspring/decimal
```

Судя по сообщениям об ошибках, чтобы собрать программу, нужно добавить ссылки на сторонние модули в файл go.mod, а для этого можно воспользоваться командой go get, которая загрузит модули и обновит файл go.mod.

Помимо обновления go.mod, был создан файл go.sum. Для каждого модуля в дереве зависимостей вашего проекта в файл go.sum добавляется одна или две записи: одна содержит имя модуля, его версию и хеш, а другая — хеш файла go.mod модуля.

### СЕМАНТИЧЕСКОЕ ВЕРСИОНИРОВАНИЕ

Практика снабжения программ номерами версий существует с незапамятных времен, но при этом нет единого подхода к тому, что следует понимать под номером версии. В Go модулям присваивают номера версий в соответствии с правилами семантического версионирования (semantic versioning, SemVer). Придерживаясь требования по применению семантического версионирования для модулей, Go упрощает управление ими, вместе с тем гарантируя, что пользователи модуля будут понимать, чего следует ожидать от нового релиза. 

Если вы еще не знаете, что такое семантическое версионирование, то можете ознакомиться с полной спецификацией этого подхода по адресу https:// semver.org. Кратко суть данного подхода сводится к тому, что номер версии составляется из трех частей: старшего номера версии, младшего номера версии и номера исправления. Эти номера записываются в форме старший_номер.младший_номер.номер_исправления (major.minor.patch) и начинаются с буквы v. Номер исправления увеличивается с каждым выпуском исправленной программы, младший номер увеличивается (со сбросом в 0 номера исправления) при добавлении новой обратно совместимой возможности, а старший номер увеличивается (со сбросом в 0 младшего номера и номера исправления) при внесении изменений, нарушающих обратную совместимость.

### Публикация своего модуля

Чтобы сделать свой модуль доступным для других пользователей, нужно просто разместить его в системе управления версиями. Это справедливо и для проектов с открытым исходным кодом, распространяемых с помощью такой общедоступной системы управления версиями, как GitHub, и для коммерческих проектов, хранимых внутри организации.

### Версионирование своего модуля

Вне зависимости от того, является ли ваш модуль общедоступным или закрытым, вы должны обеспечить его надлежащее версионирование, чтобы он мог корректно взаимодействовать с системой модулей языка Go.

Семантическое версионирование, принятое в Go, поддерживает концепцию пререлизов (предварительных версий). Предположим, текущая версия вашего модуля имеет номер v1.3.4. Вы работаете над версией 1.4.0, которая еще не совсем готова, и хотели бы попробовать импортировать ее в другой модуль. В таком случае в конец тега с номером версии добавьте дефис (-), а затем идентификатор предварительной версии, например v1.4.0-beta1 для первой бета-версии версии 1.4.0 или v1.4.0-rc2 для второго кандидата на выпуск. Чтобы добавить зависимость от предварительной версии, укажите ее явно в команде go get, так как по умолчанию Go не выбирает предварительные версии.



