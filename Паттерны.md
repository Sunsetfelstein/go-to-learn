
### 1. Декоратор

Это структурный паттерн, который позволяет добавлять новое поведение объектам, помещая их в "обертки" (wrappers).

Кроме того, наличие стандартных интерфейсов делает возможным применение паттерна «Декоратор». В Go часто задействуются фабричные функции, которые принимают экземпляр интерфейса и возвращают другой тип, который реализует тот же интерфейс. 

Допустим, у вас есть функция с таким определением: 

``` go
func process(r io.Reader) error
```

В таком случае для обработки данных из файла можно использовать следующий код: 

``` go
r, err := os.Open(fileName) 
if err != nil { 
	return err 
} 
defer r.Close() 
return process(r)
```

Экземпляр os.File, возвращаемый функцией os.Open, соответствует интерфейсу io.Reader и может использоваться в любом коде, читающем данные. Для чтения сжатых файлов в формате GZIP вы можете обернуть интерфейс io.Reader еще одним интерфейсом io.Reader: 

``` go
r, err := os.Open(fileName) 
if err != nil { 
	return err 
} 
defer r.Close() 
gz, err = gzip.NewReader(r) 
if err != nil { 
	return err 
} 
defer gz.Close() 
return process(gz)
```

Теперь тот же код, который прежде читал несжатые файлы, будет читать сжатые.

Ничто не мешает типу, который соответствует интерфейсу, определить дополнительные методы, помимо входящих в интерфейс. Эти методы могут применяться лишь в определенной части клиентского кода. Так, например, тип io.File одновременно соответствует и интерфейсу io.Reader, и интерфейсу io.Writer. Если вашему коду требуется только чтение из файла, используйте для обращения к экземпляру файла интерфейс io.Reader, не принимая во внимание другие методы.
